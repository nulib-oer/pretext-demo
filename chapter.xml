<?xml version="1.0" encoding="UTF-8" ?>
<section acro="RREF">
    <title>Reduced Row-Echelon Form</title>

    <!-- %%%%%%%%%% -->
    <!-- % -->
    <!-- %  Section RREF -->
    <!-- %  Reduced Row-Echelon Form -->
    <!-- % -->
    <!-- %%%%%%%%%% -->
    <introduction>
        <p>After solving a few systems of equations, you will recognize that it does not matter so much <em>what</em> we call our variables, as opposed to what numbers act as their coefficients.  A system in the variables $x_1,\,x_2,\,x_3$  would behave the same if we changed the names of the variables to $a,\,b,\,c$ and kept all the constants the same and in the same places.  In this section, we will isolate the key bits of information about a system of equations into something called a matrix, and then use this matrix to systematically solve the equations.  Along the way we will obtain one of our most important and useful computational tools.</p>

    </introduction>

    <subsection acro="MVNSE">
        <title>Matrix and Vector Notation for Systems of Equations</title>

        <definition acro="M" index="matrix">
            <title>Matrix</title>
            <p>An $m\times n$ <define>matrix</define> is a rectangular layout of numbers from $\complex{\null}$ having $m$ rows and $n$ columns.  We will use upper-case Latin letters from the start of the alphabet ($A,\,B,\,C,\dotsc$) to denote matrices and squared-off brackets to delimit the layout.  Many use large parentheses instead of brackets <mdash />
 the distinction is not important.  Rows of a matrix will be referenced starting at the top and working down (<ie />
 row 1 is at the top) and columns will be referenced starting from the left (<ie />
 column 1 is at the left).  For a matrix $A$, the notation $\matrixentry{A}{ij}$ will refer to the complex number in row $i$ and column $j$ of $A$.</p>

    <notation acro="M" index="matrix">
        <title>Matrix</title>
        <usage>$A$</usage>
    </notation>
    <notation acro="ME" index="matrix entries">
        <title>Matrix Entries</title>
        <usage>$\matrixentry{A}{ij}$</usage>
    </notation>
</definition>

<p>Be careful with this notation for individual entries, since it is easy to think that $\matrixentry{A}{ij}$ refers to the <em>whole</em> matrix.  It does not.  It is just a <em>number</em>, but is a convenient way to talk about the individual entries simultaneously.  This notation will get a heavy workout once we get to <acroref type="chapter" acro="M" />
.</p>

<example acro="AM" index="matrix">
    <title>A matrix</title>

    <p>
        <equation> B=\begin{bmatrix}
            <![CDATA[-1&2&5&3\\]]>
            <![CDATA[1&0&-6&1\\]]>
            <![CDATA[-4&2&2&-2]]>
\end{bmatrix}
        </equation>
is a matrix with $m=3$ rows and $n=4$ columns.  We can say that $\matrixentry{B}{2,3}=-6$ while $\matrixentry{B}{3,4}=-2$.</p>

</example>

<sageadvice acro="M" index="matrix creation">
    <title>Matrices</title>

    <p>Matrices are fundamental objects in linear algebra and in Sage, so there are a variety of ways to construct a matrix in Sage.  Generally, you need to specify what types of entries the matrix contains (more on that in a minute), the number of rows and columns, and the entries themselves.  First, let us dissect an example:</p>

    <sage>
        <input>A = matrix(QQ, 2, 3, [[1, 2, 3], [4, 5, 6]])
A
        </input>
        <output>[1 2 3]
[4 5 6]
        </output>
    </sage>

    <p>
        <code>QQ</code> is the set of all rational numbers (fractions with an integer numerator and denominator), <code>2</code> is the number of rows, <code>3</code> is the number of columns.  Sage understands a list of items as delimited by brackets (<code>[,]</code>) and the items in the list can again be lists themselves.  So <code>[[1, 2, 3], [4, 5, 6]]</code> is a list of lists, and in this context the inner lists are rows of the matrix.</p>

    <p>There are various shortcuts you can employ when creating a matrix.  For example, Sage is able to infer the size of the matrix from the lists of entries.</p>

    <sage>
        <input>B = matrix(QQ, [[1, 2, 3], [4, 5, 6]])
B
        </input>
        <output>[1 2 3]
[4 5 6]
        </output>
    </sage>

    <p>Or you can specify how many rows the matrix will have and provide one big grand list of entries, which will get chopped up, row by row, if you prefer.</p>

    <sage>
        <input>C = matrix(QQ, 2, [1, 2, 3, 4, 5, 6])
C
        </input>
        <output>[1 2 3]
[4 5 6]
        </output>
    </sage>

    <p>It is possible to also skip specifying the type of numbers used for entries of a matrix, however this is fraught with peril, as Sage will make an informed guess about your intent.  Is this what you want?  Consider when you enter the single character <q>2</q> into a computer program like Sage.  Is this the integer $2$, the rational number $\frac{2}{1}$, the real number $2.00000$, the complex number $2 + 0i$, or the polynomial $p(x)=2$?  In context, us humans can usually figure it out, but a literal-minded computer is not so smart.  It happens that the operations we can perform, and how they behave, are influenced by the type of the entries in a matrix.  So it is important to get this right and our advice is to be explicit and be in the habit of always specifying the type of the entries of a matrix you create.</p>

    <p>Mathematical objects in Sage often come from sets of similar objects.  This set is called the <q>parent</q> of the element.  We can use this to learn how Sage deduces the type of entries in a matrix.  Execute the following three compute cells in the Sage notebook, and notice how the three matrices are constructed to have entries from the integers, the rationals and the reals.</p>

    <sage>
        <input>A = matrix(2, 3, [[1, 2, 3], [4, 5, 6]])
A.parent()
        </input>
        <output>Full MatrixSpace of 2 by 3 dense matrices over Integer Ring
        </output>
    </sage>

    <sage>
        <input>B = matrix(2, 3, [[1, 2/3, 3], [4, 5, 6]])
B.parent()
        </input>
        <output>Full MatrixSpace of 2 by 3 dense matrices over Rational Field
        </output>
    </sage>

    <sage>
        <input>C = matrix(2, 3, [[1, sin(2.2), 3], [4, 5, 6]])
C.parent()
        </input>
        <output>Full MatrixSpace of 2 by 3 dense matrices over
Real Field with 53 bits of precision
        </output>
    </sage>

    <p>Sage knows a wide variety of sets of numbers.  These are known as <q>rings</q> or <q>fields</q> (see <acroref type="section" acro="F" />
), but we will call them <q>number systems</q> here.  Examples include: <code>ZZ</code> is the integers, <code>QQ</code> is the rationals, <code>RR</code> is the real numbers with reasonable precision, and <code>CC</code> is the complex numbers with reasonable precision.  We will present the theory of linear algebra over the complex numbers.  However, in any computer system, there will always be complications surrounding the inability of digital arithmetic to accurately represent all complex numbers.  In contrast, Sage can represent rational numbers exactly as the quotient of two (perhaps very large) integers.  So our Sage examples will begin by using <code>QQ</code> as our number system and we can concentrate on understanding the key concepts.</p>

<p>Once we have constructed a matrix, we can learn a lot about it (such as its parent).  Sage is largely object-oriented, which means many commands apply to an object by using the <q>dot</q> notation.  <code>A.parent()</code> is an example of this syntax, while the constructor <code>matrix([[1, 2, 3], [4, 5, 6]])</code> is an exception.  Here are a few examples, followed by some explanation:</p>

<sage>
    <input>A = matrix(QQ, 2, 3, [[1,2,3],[4,5,6]])
A.nrows(), A.ncols()
    </input>
    <output>(2, 3)
    </output>
</sage>

<sage>
    <input>A.base_ring()
    </input>
    <output>Rational Field
    </output>
</sage>

<sage>
    <input>A[1,1]
    </input>
    <output>5
    </output>
</sage>

<sage>
    <input>A[1,2]
    </input>
    <output>6
    </output>
</sage>

<p>The number of rows and the number of columns should be apparent, <code>.base_ring()</code> gives the number system for the entries, as included in the information provided by <code>.parent()</code>.
</p>

<p>Computer scientists and computer languages prefer to begin counting from zero, while mathematicians and written mathematics prefer to begin counting at one.  Sage and this text are no exception.  It takes some getting used to, but the reasons for counting from zero in computer programs soon becomes very obvious.  Counting from one in mathematics is historical, and unlikely to change anytime soon.  So above, the two rows of <code>A</code> are numbered 0 and 1, while the columns are numbered 0, 1 and 2.  So <code>A[1,2]</code> refers to the entry of <code>A</code> in the second row and the third column, <ie />
<code>6</code>.
</p>

<p>There is much more to say about how Sage works with matrices, but this is already a lot to digest.  Use the space below to create some matrices (different ways) and examine them and their properties (size, entries, number system, parent).</p>

</sageadvice>

<p>When we do equation operations on system of equations, the names of the variables really are not very important.  Use $x_1$, $x_2$, $x_3$, or $a$, $b$, $c$, or $x$, $y$, $z$, it really does not matter.  In this subsection we will describe some notation that will make it easier to describe linear systems, solve the systems and describe the solution sets.  Here is a list of definitions, laden with notation.</p>

<definition acro="CV" index="vector!column">
<title>Column Vector</title>
<p>A <define>column vector</define> of <define>size</define> $m$ is an ordered list of $m$ numbers, which is written in order vertically, starting at the top and proceeding to the bottom.  At times, we will refer to a column vector as simply a <define>vector</define>.  Column vectors will be written in bold, usually with lower case Latin letter from the end of the alphabet such as $\vect{u}$, $\vect{v}$, $\vect{w}$, $\vect{x}$, $\vect{y}$, $\vect{z}$.  Some books like to write vectors with arrows, such as $\vec{u}$.  Writing by hand, some like to put arrows on top of the symbol, or a tilde underneath the symbol, as in $\underset{\sim}{\textstyle u}$.  To refer to the <define>entry</define> or <define>component</define> of vector $\vect{v}$ in location $i$ of the list, we write $\vectorentry{\vect{v}}{i}$.</p>

<notation acro="CV" index="vector">
<title>Column Vector</title>
<usage>$\vect{v}$</usage>
</notation>
<notation acro="CVE" index="vector entries">
<title>Column Vector Entries</title>
<usage>$\vectorentry{\vect{v}}{i}$</usage>
</notation>
</definition>

<p>Be careful with this notation.  While the symbols $\vectorentry{\vect{v}}{i}$ might look somewhat substantial, as an object this represents just one entry of a vector, which is just a single complex number.</p>

<definition acro="ZCV" index="zero column vector">
<title>Zero Column Vector</title>
<p>The <define>zero vector</define> of size $m$ is the column vector of size $m$ where each entry is the number zero,
<alignmath> \zerovector=
\colvector{0\\0\\0\\\vdots\\0}
</alignmath>
or defined much more compactly, $\vectorentry{\zerovector}{i}=0$ for $1\leq i\leq m$.</p>

<notation acro="ZCV" index="zero column vector">
<title>Zero Column Vector</title>
<usage>$\zerovector$</usage>
</notation>
</definition>

<sageadvice acro="V" index="vector creation">
<title>Vectors</title>

<p>Vectors in Sage are built, manipulated and interrogated in much the same way as matrices (see <acroref type="sage" acro="M" />
).  However as simple lists (<q>one-dimensional,</q> not <q>two-dimensional</q> such as matrices that look more tabular) they are simpler to construct and manipulate.  Sage will print a vector across the screen, even if we wish to interpret it as a column vector.  It will be delimited by parentheses (<code>(,)</code>) which allows us to distinguish a vector from a matrix with just one row, if we look carefully.  The number of <q>slots</q> in a vector is not referred to in Sage as rows or columns, but rather by <q>degree.</q>  Here are some examples (remember to start counting from zero):</p>

<sage>
<input>v = vector(QQ, 4, [1, 1/2, 1/3, 1/4])
v
</input>
<output>(1, 1/2, 1/3, 1/4)
</output>
</sage>

<sage>
<input>v.degree()
</input>
<output>4
</output>
</sage>

<sage>
<input>v.parent()
</input>
<output>Vector space of dimension 4 over Rational Field
</output>
</sage>

<sage>
<input>v[2]
</input>
<output>1/3
</output>
</sage>

<sage>
<input>w = vector([1, 2, 3, 4, 5, 6])
w
</input>
<output>(1, 2, 3, 4, 5, 6)
</output>
</sage>

<sage>
<input>w.degree()
</input>
<output>6
</output>
</sage>

<sage>
<input>w.parent()
</input>
<output>Ambient free module of rank 6 over
the principal ideal domain Integer Ring
</output>
</sage>

<sage>
<input>w[3]
</input>
<output>4
</output>
</sage>

<p>Notice that if you use commands like <code>.parent()</code> you will sometimes see references to <q>free modules.</q>  This is a technical generalization of the notion of a vector, which is beyond the scope of this course, so just mentally convert to vectors when you see this term.</p>

<p>The zero vector is super easy to build, but be sure to specify what number system your zero is from.</p>

<sage>
<input>z = zero_vector(QQ, 5)
z
</input>
<output>(0, 0, 0, 0, 0)
</output>
</sage>

<p>Notice that while using Sage, we try to remain consistent with our mathematical notation conventions.  This is not required, as you can give items in Sage very long names if you wish.  For example, the following is perfectly legitimate, as you can see.</p>

<sage>
<input>blatzo = matrix(QQ, 2, [1, 2, 3, 4])
blatzo
</input>
<output>[1 2]
[3 4]
</output>
</sage>

<p>In fact, our use of capital letters for matrices actually contradicts some of the conventions for naming objects in Sage, so there are good reasons for <em>not</em> mirroring our mathematical notation.</p>

</sageadvice>

<definition acro="CM" index="coefficient matrix">
<title>Coefficient Matrix</title>
<p>For a system of linear equations,
<alignmath>
<![CDATA[a_{11}x_1+a_{12}x_2+a_{13}x_3+\dots+a_{1n}x_n&=b_1\\]]>
<![CDATA[a_{21}x_1+a_{22}x_2+a_{23}x_3+\dots+a_{2n}x_n&=b_2\\]]>
<![CDATA[a_{31}x_1+a_{32}x_2+a_{33}x_3+\dots+a_{3n}x_n&=b_3\\]]>
<![CDATA[\vdots&\\]]>
<![CDATA[a_{m1}x_1+a_{m2}x_2+a_{m3}x_3+\dots+a_{mn}x_n&=b_m]]>
</alignmath>
the <define>coefficient matrix</define> is the $m\times n$ matrix
<equation> A=
\begin{bmatrix}
<![CDATA[a_{11}&a_{12}&a_{13}&\dots&a_{1n}\\]]>
<![CDATA[a_{21}&a_{22}&a_{23}&\dots&a_{2n}\\]]>
<![CDATA[a_{31}&a_{32}&a_{33}&\dots&a_{3n}\\]]>
<![CDATA[\vdots&\\]]>
<![CDATA[a_{m1}&a_{m2}&a_{m3}&\dots&a_{mn}\\]]>
\end{bmatrix}
</equation>
</p>

</definition>

<definition acro="VOC" index="vector!of constants">
<title>Vector of Constants</title>
<p>For a system of linear equations,
<alignmath>
<![CDATA[a_{11}x_1+a_{12}x_2+a_{13}x_3+\dots+a_{1n}x_n&=b_1\\]]>
<![CDATA[a_{21}x_1+a_{22}x_2+a_{23}x_3+\dots+a_{2n}x_n&=b_2\\]]>
<![CDATA[a_{31}x_1+a_{32}x_2+a_{33}x_3+\dots+a_{3n}x_n&=b_3\\]]>
<![CDATA[\vdots&\\]]>
<![CDATA[a_{m1}x_1+a_{m2}x_2+a_{m3}x_3+\dots+a_{mn}x_n&=b_m]]>
</alignmath>
the <define>vector of constants</define> is the column vector of size $m$
<equation> \vect{b}=
\begin{bmatrix}
b_1\\
b_2\\
b_3\\
\vdots\\
b_m\\
\end{bmatrix}
</equation>
</p>

</definition>

<definition acro="SOLV" index="solution vector">
<title>Solution Vector</title>
<p>For a system of linear equations,
<alignmath>
<![CDATA[a_{11}x_1+a_{12}x_2+a_{13}x_3+\dots+a_{1n}x_n&=b_1\\]]>
<![CDATA[a_{21}x_1+a_{22}x_2+a_{23}x_3+\dots+a_{2n}x_n&=b_2\\]]>
<![CDATA[a_{31}x_1+a_{32}x_2+a_{33}x_3+\dots+a_{3n}x_n&=b_3\\]]>
<![CDATA[\vdots&\\]]>
<![CDATA[a_{m1}x_1+a_{m2}x_2+a_{m3}x_3+\dots+a_{mn}x_n&=b_m]]>
</alignmath>
the <define>solution vector</define> is the column vector of size $n$
<equation> \vect{x}=
\begin{bmatrix}
x_1\\
x_2\\
x_3\\
\vdots\\
x_n\\
\end{bmatrix}
</equation>
</p>

</definition>

<p>The solution vector may do double-duty on occasion.  It might refer to a list of variable quantities at one point, and subsequently refer to values of those variables that actually form a particular solution to that system.</p>

<definition acro="MRLS" index="linear system!matrix representation">
<title>Matrix Representation of a Linear System</title>
<p>If $A$ is the coefficient matrix of a system of linear equations and $\vect{b}$ is the vector of constants, then we will write $\linearsystem{A}{\vect{b}}$ as a shorthand expression for the  system of linear equations, which we will refer to as the <define>matrix representation</define> of the linear system.</p>

<notation acro="MRLS" index="linear system!matrix representation">
<title>Matrix Representation of a Linear System</title>
<usage>$\linearsystem{A}{\vect{b}}$</usage>
</notation>
</definition>

<example acro="NSLE" index="linear systems!notation">
<title>Notation for systems of linear equations</title>

<p>The system of linear equations
<alignmath>
<![CDATA[2x_1+4x_2-3x_3+5x_4+x_5&=9\\]]>
<![CDATA[3x_1+x_2+\quad\quad x_4-3x_5&=0\\]]>
<![CDATA[-2x_1+7x_2-5x_3+2x_4+2x_5&=-3]]>
</alignmath>
has coefficient matrix
<equation> A=
\begin{bmatrix}
<![CDATA[2 & 4 & -3 & 5 & 1\\]]>
<![CDATA[3 & 1 & 0 & 1 & -3\\]]>
<![CDATA[-2 & 7 & -5 & 2 & 2]]>
\end{bmatrix}
</equation>
and vector of constants
<equation> \vect{b}=\colvector{9\\0\\-3}
</equation>
and so will be referenced as $\linearsystem{A}{\vect{b}}$.</p>

</example>

<definition acro="AM" index="matrix!augmented">
<title>Augmented Matrix</title>
<p>Suppose we have a system of $m$ equations in $n$ variables, with coefficient matrix $A$ and vector of constants $\vect{b}$.  Then the <define>augmented matrix</define> of the system of equations is the $m\times(n+1)$ matrix whose first $n$ columns are the columns of $A$ and whose last column ($n+1$) is the column vector $\vect{b}$.  This matrix will be written as $\augmented{A}{\vect{b}}$.</p>

<notation acro="AM" index="augmented matrix">
<title>Augmented Matrix</title>
<usage>$\augmented{A}{\vect{b}}$</usage>
</notation>
</definition>

<p>The augmented matrix <em>represents</em> all the important information in the system of equations, since the names of the variables have been ignored, and the only connection with the variables is the location of their coefficients in the matrix.  It is important to realize that the augmented matrix is just that, a matrix, and <em>not</em> a system of equations.  In particular, the augmented matrix does not have any <q>solutions,</q> though it will be useful for finding solutions to the system of equations that it is associated with.  (Think about your objects, and review <acroref type="technique" acro="L" />
.)  However, notice that an augmented matrix always belongs to some system of equations, and vice versa, so it is tempting to try and blur the distinction between the two.  Here is a quick example.</p>

<example acro="AMAA" index="archetype A!augmented matrix">
<title>Augmented matrix for Archetype A</title>

<p>
<acroref type="archetype" acro="A" />
 is the following system of 3 equations in 3 variables.
<archetypepart acro="A" part="systemdefn" />
Here is its augmented matrix.
<alignmath>
<archetypepart acro="A" part="augmented" />
</alignmath>
</p>

</example>

<sageadvice acro="AM" index="augmented matrix">
<title>Augmented Matrix</title>

<p>Sage has a matrix method, <code>.augment()</code>, that will join two matrices, side-by-side provided they both have the same number of rows.  The same method will allow you to augment a matrix with a column vector, as described in <acroref type="definition" acro="AM" />
, provided the number of entries in the vector matches the number of rows for the matrix.  Here we reprise the construction in <acroref type="example" acro="AMAA" />
.  We will now format our matrices as input across several lines, a practice you may use in your own worksheets, or not.</p>

<sage>
<input>A = matrix(QQ, 3, 3, [[1, -1, 2],
                      [2,  1, 1],
                      [1,  1, 0]])
b = vector(QQ, [1, 8, 5])
M = A.augment(b)
M
</input>
<output>[ 1 -1  2  1]
[ 2  1  1  8]
[ 1  1  0  5]
</output>
</sage>

<p>Notice that the matrix method <code>.augment()</code> needs some input, in the above case, the vector <code>b</code>.  This will explain the need for the parentheses on the end of the <q>dot</q> commands, even if the particular command does not expect input.</p>

<p>Some methods allow optional input, typically using keywords.  Matrices can track subdivisions, making breaks between rows and/or columns.  When augmenting, you can ask for the subdivision to be included.  Evalute the compute cell above if you have not already, so that <code>A</code> and <code>b</code> are defined, and then evaluate:</p>

<sage>
<input>M = A.augment(b, subdivide=True)
M
</input>
<output>[ 1 -1  2| 1]
[ 2  1  1| 8]
[ 1  1  0| 5]
</output>
</sage>

<p>As a partial demonstration of manipulating subdivisions of matrices we can reset the subdivisions of <code>M</code> with the <code>.subdivide()</code> method.  We provide a list of rows to subdivide <em>before</em>, then a list of columns to subdivide <em>before</em>, where we remember that counting begins at zero.</p>

<sage>
<input>M.subdivide([1,2],[1])
M
</input>
<output>[ 1|-1  2  1]
[--+--------]
[ 2| 1  1  8]
[--+--------]
[ 1| 1  0  5]
</output>
</sage>

</sageadvice>
</subsection>

<subsection acro="RO">
<title>Row Operations</title>

<p>An augmented matrix for a system of equations will save us the tedium of continually writing down the names of the variables as we solve the system.  It will also release us from any dependence on the actual names of the variables.  We have seen how certain operations we can perform on equations (<acroref type="definition" acro="EO" />
) will preserve their solutions (<acroref type="theorem" acro="EOPSS" />
).  The next two definitions and the following theorem carry over these ideas to augmented matrices.</p>

<definition acro="RO" index="row operations">
<title>Row Operations</title>
<p>The following three operations will transform an $m\times n$ matrix into a different matrix of the same size, and each is known as a <define>row operation</define>.
<ol>
<li> Swap the locations of two rows.
</li>
<li> Multiply each entry of a single row by a nonzero quantity.
</li>
<li> Multiply each entry of one row by some quantity, and add these values to the entries in the same columns of a second row.  Leave the first row the same after this operation, but replace the second row by the new values.
</li>
</ol>
We will use a symbolic shorthand to describe these row operations:
<ol>
<li> $\rowopswap{i}{j}$: Swap the location of rows $i$ and $j$.
</li>
<li> $\rowopmult{\alpha}{i}$: Multiply row $i$ by the nonzero scalar $\alpha$.
</li>
<li> $\rowopadd{\alpha}{i}{j}$: Multiply row $i$ by the scalar $\alpha$ and add to row $j$.
</li>
</ol>
</p>

<notation acro="ROS" index="row operation!swap">
<title>Row Operation, Swap</title>
<usage>$\rowopswap{i}{j}$</usage>
</notation>
<notation acro="ROM" index="row operation!multiply">
<title>Row Operation, Multiply</title>
<usage>$\rowopmult{\alpha}{i}$</usage>
</notation>
<notation acro="ROA" index="row operation!add">
<title>Row Operation, Add</title>
<usage>$\rowopadd{\alpha}{i}{j}$</usage>
</notation>
</definition>

<definition acro="REM" index="row-equivalent matrices">
<title>Row-Equivalent Matrices</title>
<p>Two matrices, $A$ and $B$, are <define>row-equivalent</define> if one can be obtained from the other by a sequence of row operations.</p>

</definition>

<example acro="TREM" index="row-equivalent matrices">
<title>Two row-equivalent matrices</title>

<p>The matrices
<alignmath> A=\begin{bmatrix}
<![CDATA[2&-1&3&4\\]]>
<![CDATA[5&2&-2&3\\]]>
<![CDATA[1&1&0&6]]>
\end{bmatrix}
<![CDATA[&&]]> B=\begin{bmatrix}
<![CDATA[1&1&0&6\\]]>
<![CDATA[3&0&-2&-9\\]]>
<![CDATA[2&-1&3&4]]>
\end{bmatrix}
</alignmath>
are row-equivalent as can be seen from
<alignmath>
\begin{bmatrix}
<![CDATA[2&-1&3&4\\]]>
<![CDATA[5&2&-2&3\\]]>
<![CDATA[1&1&0&6]]>
\end{bmatrix}
\xrightarrow{\rowopswap{1}{3}}
\begin{bmatrix}
<![CDATA[1&1&0&6\\]]>
<![CDATA[5&2&-2&3\\]]>
<![CDATA[2&-1&3&4]]>
\end{bmatrix}
<![CDATA[&]]>
\xrightarrow{\rowopadd{-2}{1}{2}}
\begin{bmatrix}
<![CDATA[1&1&0&6\\]]>
<![CDATA[3&0&-2&-9\\]]>
<![CDATA[2&-1&3&4]]>
\end{bmatrix}
</alignmath>
We can also say that any pair of these three matrices are row-equivalent.</p>

</example>

<p>Notice that each of the three row operations is reversible (<acroref type="exercise" acro="RREF.T10" />
), so we do not have to be careful about the distinction between <q>$A$ is row-equivalent to $B$</q> and <q>$B$ is row-equivalent to $A$.</q> (<acroref type="exercise" acro="RREF.T11" />
)</p>

<p>The preceding definitions are designed to make the following theorem possible.  It says that row-equivalent matrices represent systems of linear equations that have identical solution sets.</p>

<theorem acro="REMES" index="row-equivalent matrices">
<title>Row-Equivalent Matrices represent Equivalent Systems</title>
<statement>
<p>Suppose that $A$ and $B$ are row-equivalent augmented matrices.  Then the systems of linear equations that they represent are equivalent systems.</p>

</statement>

<proof>
<p>If we perform a single row operation on an augmented matrix, it will have the same effect as if we did the analogous equation operation on the system of equations the matrix represents.  By exactly the same methods as we used in the proof of <acroref type="theorem" acro="EOPSS" />
 we can see that each of these row operations will preserve the set of solutions for the system of equations the matrix represents.</p>

</proof>
</theorem>

<p>So at this point, our strategy is to begin with a system of equations, represent the system by an augmented matrix, perform row operations (which will preserve solutions for the system) to get a <q>simpler</q> augmented matrix, convert back to a <q>simpler</q>  system of equations and then solve that system, knowing that its solutions are those of the original system.  Here is a rehash of <acroref type="example" acro="US" />
 as an exercise in using our new tools.</p>

<!-- MBX: index entry may have math needing adjustment -->
<example acro="USR" index="unique solution, 3\times 3">
<title>Three equations, one solution, reprised</title>

<p>We solve the following system using augmented matrices and row operations.  This is the same system of equations solved in <acroref type="example" acro="US" />
 using equation operations.
<alignmath>
<![CDATA[x_1+2x_2+2x_3&=4\\]]>
<![CDATA[x_1+3x_2+3x_3&=5\\]]>
<![CDATA[2x_1+6x_2+5x_3&=6]]>
</alignmath>
Form the augmented matrix,
<alignmath> A=\begin{bmatrix}
<![CDATA[1&2&2&4\\]]>
<![CDATA[1&3&3&5\\]]>
<![CDATA[2&6&5&6]]>
\end{bmatrix}
</alignmath>
and apply row operations,
<alignmath>
\xrightarrow{\rowopadd{-1}{1}{2}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[1&2&2&4\\]]>
<![CDATA[0&1&1&1\\]]>
<![CDATA[2&6&5&6]]>
\end{bmatrix}
\xrightarrow{\rowopadd{-2}{1}{3}}
\begin{bmatrix}
<![CDATA[1&2&2&4\\]]>
<![CDATA[0&1&1&1\\]]>
<![CDATA[0&2&1&-2]]>
\end{bmatrix}\\
\xrightarrow{\rowopadd{-2}{2}{3}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[1&2&2&4\\]]>
<![CDATA[0&1&1&1\\]]>
<![CDATA[0&0&-1&-4]]>
\end{bmatrix}
\xrightarrow{\rowopmult{-1}{3}}
\begin{bmatrix}
<![CDATA[1&2&2&4\\]]>
<![CDATA[0&1& 1&1\\]]>
<![CDATA[0&0&1&4]]>
\end{bmatrix}
</alignmath>
</p>

<p>So the matrix
<equation> B=\begin{bmatrix}
<![CDATA[1&2&2&4\\]]>
<![CDATA[0&1& 1&1\\]]>
<![CDATA[0&0&1&4]]>
\end{bmatrix}
</equation>
is row equivalent to $A$
and by <acroref type="theorem" acro="REMES" />
 the system of equations below has the same solution set as the original system of equations.
<alignmath>
<![CDATA[x_1+2x_2+2x_3&=4\\]]>
<![CDATA[x_2+ x_3&=1\\]]>
<![CDATA[x_3&=4]]>
</alignmath>
</p>

<p>Solving this <q>simpler</q> system is straightforward and is identical to the process in <acroref type="example" acro="US" />
.</p>

</example>

<sageadvice acro="RO" index="row operations">
<title>Row Operations</title>

<p>Sage will perform individual row operations on a matrix.  This can get a bit tedious, but it is better than doing the computations (wrong, perhaps) by hand, and it can be useful when building up more complicated procedures for a matrix.</p>

<p>For each row operation, there are two similar methods.  One changes the matrix <q>in-place</q> while the other creates a new matrix that is a modified version of the original.  This is an important distinction that you should understand for every new Sage command you learn that might change a matrix or vector.</p>

<p>Consider the first row operation, which swaps two rows.  There are two matrix methods to do this, a <q>with</q> version that will create a new, changed matrix, which you will likely want to save, and a plain version that will change the matrix it operates on <q>in-place.</q>.  The <code>copy()</code> function, which is a general-purpose command, is a way to make a copy of a matrix before you make changes to it.  Study the example below carefully, and then read the explanation following. (Remember that counting begins with zero.)</p>

<sage>
<input>A = matrix(QQ,2,3,[1,2,3,4,5,6])
B = A
C = copy(A)
D = A.with_swapped_rows(0,1)
D[0,0] = -1
A.swap_rows(0,1)
A[1,2] = -6
A
</input>
<output>[ 4  5  6]
[ 1  2 -6]
</output>
</sage>

<sage>
<input>B
</input>
<output>[ 4  5  6]
[ 1  2 -6]
</output>
</sage>

<sage>
<input>C
</input>
<output>[1 2 3]
[4 5 6]
</output>
</sage>

<sage>
<input>D
</input>
<output>[-1  5  6]
[ 1  2  3]
</output>
</sage>

<p>Here is how each of these four matrices comes into existence.</p>

<ol>
<li>
<code>A</code> is our original matrix, created from a list of entries.
</li>
<li>
<code>B</code> is not a new copy of <code>A</code>, it is just a new name for referencing the exact same matrix internally.
</li>
<li>
<code>C</code> is a brand new matrix, stored internally separate from <code>A</code>, but with identical contents.
</li>
<li>
<code>D</code> is also a new matrix, which is created by swapping the rows of <code>A</code>
</li>
</ol>

<p>And here is how each matrix is affected by the commands.</p>

<ol>
<li>
<code>A</code> is changed twice <q>in-place</q>.  First, its rows are swapped rows a <q>plain</q> matrix method.  Then its entry in the lower-right corner is set to <code>-6</code>.
</li>
<li>
<code>B</code> is just another name for <code>A</code>.  So whatever changes are made to <code>A</code> will be evident when we ask for the matrix by the name <code>B</code>.  And vice-versa.
</li>
<li>
<code>C</code> is a copy of the original <code>A</code> and does not change, since no subsequent commands act on <code>C</code>.
</li>
<li>
<code>D</code> is a new copy of <code>A</code>, created by swapping the rows of <code>A</code>.  Once created from <code>A</code>, it has a life of its own, as illustrated by the change in its entry in the upper-left corner to <code>-1</code>.
</li>
</ol>

<p>An interesting experiment is to rearrange some of the lines above (or add new ones) and predict the result.</p>

<p>Just as with the first row operation, swapping rows, Sage supports the other two row operations with natural sounding commands, with both <q>in-place</q> versions and new-matrix versions.</p>

<sage>
<input>A = matrix(QQ, 3, 4, [[1,  2,  3,  4],
                      [5,  6,  7,  8],
                      [9, 10, 11, 12]])
B = copy(A)
A.rescale_row(1, 1/2)
A
</input>
<output>[  1   2   3   4]
[5/2   3 7/2   4]
[  9  10  11  12]
</output>
</sage>

<sage>
<input>A.add_multiple_of_row(2, 0, 10)
A
</input>
<output>[  1   2   3   4]
[5/2   3 7/2   4]
[ 19  30  41  52]
</output>
</sage>

<sage>
<input>B.with_rescaled_row(1, 1/2)
</input>
<output>[  1   2   3   4]
[5/2   3 7/2   4]
[  9  10  11  12]
</output>
</sage>

<sage>
<input>C = B.with_added_multiple_of_row(2, 0, 10)
C
</input>
<output>[ 1  2  3  4]
[ 5  6  7  8]
[19 30 41 52]
</output>
</sage>

<p>Notice that the order of the arguments might feel a bit odd, compared to how we write and think about row operations.  Also note how the <q>with</q> versions leave a trail of matrices for each step while the plain versions just keep changing <code>A</code>.
</p>

</sageadvice>
</subsection>

<subsection acro="RREF">
<title>Reduced Row-Echelon Form</title>

<p>The preceding example amply illustrates the definitions and theorems we have seen so far.  But it still leaves two questions unanswered.  Exactly what is this <q>simpler</q> form for a matrix, and just how do we get it?  Here is the answer to the first question, a definition of reduced row-echelon form.</p>

<definition acro="RREF" index="reduced row-echelon form">
<title>Reduced Row-Echelon Form</title>
<p>A matrix is in <define>reduced row-echelon form</define> if it meets all of the following conditions:
<ol>
<li> If there is a row where every entry is zero, then this row lies below any other row that contains a nonzero entry.
</li>
<li> The leftmost nonzero entry of a row is equal to 1.
</li>
<li> The leftmost nonzero entry of a row is the only nonzero entry in its column.
</li>
<li> Consider any two different leftmost nonzero entries, one located in row $i$, column $j$ and the other located in row $s$, column $t$.  If $s>i$, then $t>j$.
</li>
</ol>
A row of only zero entries is called a <define>zero row</define> and the leftmost nonzero entry of a nonzero row is a <define>leading 1</define>.  A column containing a leading 1 will be called a <define>pivot column</define>.  The number of nonzero rows will be denoted by $r$, which is also equal to the number of leading 1's and the number of pivot columns.</p>

<p>The set of column indices for the pivot columns will be denoted by $D=\set{d_1,\,d_2,\,d_3,\,\ldots,\,d_r}$ where $d_1\lt d_2\lt d_3\lt\cdots\lt d_r$, while the columns that are not pivot columns will be denoted as $F=\set{f_1,\,f_2,\,f_3,\,\ldots,\,f_{n-r}}$ where $f_1\lt f_2\lt f_3\lt\cdots\lt f_{n-r}$.</p>

<notation acro="RREFA" index="reduced row-echelon form!analysis">
<title>Reduced Row-Echelon Form Analysis</title>
<usage>$r$, $D$, $F$</usage>
</notation>
</definition>

<p>The principal feature of reduced row-echelon form is the pattern of leading 1's guaranteed by conditions (2) and (4), reminiscent of a flight of geese, or steps in a staircase, or water cascading down a mountain stream.</p>

<p>There are a number of new terms and notation introduced in this definition, which should make you suspect that this is an important definition.  Given all there is to digest here, we will mostly save the use of $D$ and $F$ until <acroref type="section" acro="TSS" />
.  However, one important point to make here is that all of these terms and notation apply to a matrix.  Sometimes we will employ these terms and sets for an augmented matrix, and other times it might be a coefficient matrix.  So always give some thought to exactly which type of matrix you are analyzing.</p>

<example acro="RREF" index="reduced row-echelon form">
<title>A matrix in reduced row-echelon form</title>

<p>The matrix $C$ is in reduced row-echelon form.
<alignmath>
<![CDATA[C&=]]>
\begin{bmatrix}
<![CDATA[1&-3&0&6&0&0&-5&9\\]]>
<![CDATA[0&0&0&0&1&0&3&-7\\]]>
<![CDATA[0&0&0&0&0&1&7&3\\]]>
<![CDATA[0&0&0&0&0&0&0&0\\]]>
<![CDATA[0&0&0&0&0&0&0&0]]>
\end{bmatrix}
</alignmath>
This matrix has two zero rows and three pivot columns.   So $r=3$.  Columns 1, 5, and 6 are the three pivot columns, so $D=\set{1,\,5,\,6}$ and then $F=\set{2,\,3,\,4,\,7,\,8}$.</p>

</example>

<example acro="NRREF" index="reduced row-echelon form">
<title>A matrix not in reduced row-echelon form</title>

<p>The matrix $E$ is not in reduced row-echelon form, as it fails each of the four requirements once.
<alignmath>
<![CDATA[E&=]]>
\begin{bmatrix}
<![CDATA[1&0&-3&0&6&0&7&-5&9\\]]>
<![CDATA[0&0&0&5&0&1&0&3&-7\\]]>
<![CDATA[0&0&0&0&0&0&0&0&0\\]]>
<![CDATA[0&1&0&0&0&0&0&-4&2\\]]>
<![CDATA[0&0&0&0&0&0&1&7&3\\]]>
<![CDATA[0&0&0&0&0&0&0&0&0]]>
\end{bmatrix}
</alignmath>
</p>

</example>

<p>Our next theorem has a <q>constructive</q> proof.  Learn about the meaning of this term in <acroref type="technique" acro="C" />
.</p>

<theorem acro="REMEF" index="row-reduced matrices">
<title>Row-Equivalent Matrix in Echelon Form</title>
<statement>
<p>Suppose $A$ is a matrix.  Then there is a matrix $B$ so that
<ol>
<li> $A$ and $B$ are row-equivalent.
</li>
<li> $B$ is in reduced row-echelon form.
</li>
</ol>
</p>

</statement>

<proof>
<p>Suppose that $A$ has $m$ rows and $n$ columns.  We will describe a process for converting $A$ into $B$ via row operations.  This procedure is known as <define>Gauss-Jordan elimination</define>.  Tracing through this procedure will be easier if you recognize that $i$ refers to a row that is being converted, $j$ refers to a column that is being converted, and $r$ keeps track of the number of nonzero rows.  Here we go.</p>

<p>
<ol>
<!--1-->
<li>Set $j=0$ and $r=0$.</li>
<!--2-->
<li>Increase $j$ by 1.  If $j$ now equals $n+1$, then stop.</li>
<!--3-->
<li>Examine the entries of $A$ in column $j$ located in rows $r+1$ through $m$.  If all of these entries are zero, then go to Step 2.</li>
<!--4-->
<li>Choose a row from rows $r+1$ through $m$ with a nonzero entry in column $j$.  Let $i$ denote the index for this row.</li>
<!--5-->
<li>Increase $r$ by 1.</li>
<!--6-->
<li>Use the first row operation to swap rows $i$ and $r$.</li>
<!--7-->
<li>Use the second row operation to convert the entry in row $r$ and column $j$ to a 1.</li>
<!--8-->
<li>Use the third row operation with row $r$ to convert every other entry of column $j$ to zero.</li>
<!--9-->
<li>Go to Step 2.</li>
</ol>
</p>

<p>The result of this procedure is that the matrix $A$ is converted to a matrix in reduced row-echelon form, which we will refer to as $B$.  We need to now prove this claim by showing that the converted matrix has the requisite properties of <acroref type="definition" acro="RREF" />
.  First, the matrix is only converted through row operations (Steps 6, 7, 8), so $A$ and $B$ are row-equivalent (<acroref type="definition" acro="REM" />
).</p>

<p>It is a bit more work to be certain that $B$ is in reduced row-echelon form.
We claim that as we begin Step 2, the first $j$ columns of the matrix are in reduced row-echelon form with $r$ nonzero rows.   Certainly this is true at the start when $j=0$, since the matrix has no columns and so vacuously meets the conditions of <acroref type="definition" acro="RREF" />
 with $r=0$ nonzero rows.</p>

<p>In Step 2 we increase $j$ by 1 and begin to work with the next column.  There are two possible outcomes for Step 3.  Suppose that every entry of column $j$ in rows $r+1$ through $m$ is zero.  Then with no changes we recognize that the first $j$ columns of the matrix has its first $r$ rows still in reduced-row echelon form, with the final $m-r$ rows still all zero.</p>

<p>Suppose instead that the entry in row $i$ of column $j$ is nonzero.  Notice that since $r+1\leq i\leq m$, we know the first $j-1$ entries of this row are all zero.  Now, in Step 5 we increase $r$ by 1, and then embark on building a new nonzero row.  In Step 6 we swap row $r$ and row $i$.  In the first $j$ columns, the first $r-1$ rows remain in reduced row-echelon form after the swap.  In Step 7 we multiply row $r$ by a nonzero scalar, creating a 1 in the entry in column $j$ of row $i$, and not changing any other rows.  This new leading 1 is the first nonzero entry in its row, and is located to the right of all the leading 1's in the preceding $r-1$ rows.  With Step 8 we insure that every entry in the column with this new leading 1 is now zero, as required for reduced row-echelon form.  Also, rows $r+1$ through $m$ are now all zeros in the first $j$ columns, so we now only have one new nonzero row, consistent with our increase of $r$ by one.  Furthermore, since the first $j-1$ entries of row $r$ are zero, the employment of the third row operation does not destroy any of the necessary features of rows $1$ through $r-1$ and rows $r+1$ through $m$, in columns $1$ through $j-1$.</p>

<p>So at this stage, the first $j$ columns of the matrix are in reduced row-echelon form.  When Step 2 finally increases $j$ to $n+1$, then the procedure is completed and the full $n$ columns of the matrix are in reduced row-echelon form, with the value of $r$ correctly recording the number of nonzero rows.</p>

</proof>
</theorem>

<p>The procedure given in the proof of <acroref type="theorem" acro="REMEF" />
 can be more precisely described using a pseudo-code version of a computer program.  Single-letter variables, like <code>m, n, i, j, r</code> have the same meanings as above. <code>:=</code> is assignment of the value on the right to the variable on the left, <code>A[i,j]</code> is the equivalent of the matrix entry $\matrixentry{A}{ij}$, while <code>==</code> is an equality test and <code><![CDATA[<>]]></code> is a <q>not equals</q> test.
<!--   new latex environment, unsupported as of XML cutover -->
<programlisting>
input m, n and A
r := 0
for j := 1 to n
   i := r+1
   while i <![CDATA[<= m]]> and A[i,j] == 0
       i := i+1
   if i <![CDATA[<]]> m+1
       r := r+1
       swap rows i and r of A (row op 1)
       scale A[r,j] to a leading 1 (row op 2)
       for k := 1 to m, k <![CDATA[<>]]> r
           make A[k,j] zero (row op 3, employing row r)
output r and A
</programlisting>

</p>

<p>Notice that as a practical matter the <q>and</q> used in the conditional statement of the while statement should be of the <q>short-circuit</q> variety so that the array access that follows is not out-of-bounds.</p>

<p>So now we can put it all together.  Begin with a system of linear equations (<acroref type="definition" acro="SLE" />
), and represent the system by its augmented matrix (<acroref type="definition" acro="AM" />
).  Use row operations (<acroref type="definition" acro="RO" />
) to convert this matrix into reduced row-echelon form (<acroref type="definition" acro="RREF" />
), using the procedure outlined in the proof of <acroref type="theorem" acro="REMEF" />
.<acroref type="theorem" acro="REMEF" />
 also tells us we can always accomplish this, and that the result is row-equivalent (<acroref type="definition" acro="REM" />
) to the original augmented matrix.  Since the matrix in reduced-row echelon form has the same solution set, we can analyze the row-reduced version instead of the original matrix, viewing it as the augmented matrix of a different system of equations.  The beauty of augmented matrices in reduced row-echelon form is that the solution sets to the systems they represent can be easily determined, as we will see in the next few examples and in the next section.</p>

<p>We will see through the course that almost every interesting property of a matrix can be discerned by looking at a row-equivalent matrix in reduced row-echelon form.  For this reason it is important to know that the matrix $B$ is guaranteed to exist by <acroref type="theorem" acro="REMEF" />
 is also unique.</p>

<p>Two proof techniques are applicable to the proof. First, head out and read two proof techniques:  <acroref type="technique" acro="CD" />
 and <acroref type="technique" acro="U" />
.</p>

<theorem acro="RREFU" index="reduced row-echelon form!unique">
<title>Reduced Row-Echelon Form is Unique</title>
<statement>
<p>Suppose that $A$ is an $m\times n$ matrix and that $B$ and $C$ are $m\times n$ matrices that are row-equivalent to $A$ and in reduced row-echelon form.  Then $B=C$.</p>

</statement>

<proof>
<p>We need to begin with no assumptions about any relationships between $B$ and $C$, other than they are both in reduced row-echelon form, and they are both row-equivalent to $A$.</p>

<p>If $B$ and $C$ are both row-equivalent to $A$, then they are row-equivalent to each other.  Repeated row operations on a matrix combine the rows with each other using operations that are linear, and are identical in each column.  A key observation for this proof is that each individual row of $B$ is linearly related to the rows of $C$.  This relationship is different for each row of $B$, but once we fix a row, the relationship is the same across columns.  More precisely, there are scalars $\delta_{ik}$, $1\leq i,k\leq m$ such that for any $1\leq i\leq m$, $1\leq j\leq n$,
<alignmath>
\matrixentry{B}{ij}
<![CDATA[&=\sum_{k=1}^{m}\delta_{ik}\matrixentry{C}{kj}]]>
</alignmath>
</p>

<p>You should read this as saying that an entry of row $i$ of $B$ (in column $j$) is a linear function of the entries of all the rows of $C$ that are also in column $j$, and the scalars ($\delta_{ik}$) depend on which row of $B$ we are considering (the $i$ subscript on $\delta_{ik}$), but are the same for every column (no dependence on $j$ in $\delta_{ik}$).  This idea may be complicated now, but will feel more familiar once we discuss <q>linear combinations</q> (<acroref type="definition" acro="LCCV" />
) and moreso when we discuss <q>row spaces</q> (<acroref type="definition" acro="RSM" />
).  For now, spend some time carefully working <acroref type="exercise" acro="RREF.M40" />
, which is designed to illustrate the origins of this expression.  This completes our exploitation of the row-equivalence of $B$ and $C$.</p>

<p>We now repeatedly exploit the fact that $B$ and $C$ are in reduced row-echelon form.  Recall that a pivot column is all zeros, except a single one.  More carefully, if $R$ is a matrix in reduced row-echelon form, and $d_\ell$ is the index of a pivot column, then $\matrixentry{R}{kd_\ell}=1$ precisely when $k=\ell$ and is otherwise zero.  Notice also that any entry of $R$ that is both below the entry in row $\ell$ <em>and</em> to the left of column $d_\ell$ is also zero (with below and left understood to include equality).  In other words, look at examples of matrices in reduced row-echelon form and choose a leading 1 (with a box around it).  The rest of the column is also zeros, and the lower left <q>quadrant</q> of the matrix that begins here is totally zeros.</p>

<p>Assuming no relationship about the form of $B$ and $C$, let $B$ have $r$ nonzero rows and denote the pivot columns as $D=\set{\scalarlist{d}{r}}$.  For $C$ let $r^\prime$ denote the number of nonzero rows and denote the pivot columns
as
<!--  Extra thin space in set is triple brace protection for Sage worksheets -->
<!--  Maybe a space will work just as well now with straight-to MathJax --> $D^\prime=\set{\,\scalarlist{d^\prime}{r^\prime}}$ (<acroref type="definition" acro="RREF" />
).  There are four steps in the proof, and the first three are about showing that $B$ and $C$ have the same number of pivot columns, in the same places.  In other words, the <q>primed</q> symbols are a necessary fiction.</p>

<p>First Step.  Suppose that $d_1\lt d^\prime_1$.  Then
<alignmath>
1
<![CDATA[&=\matrixentry{B}{1d_1}]]>
<![CDATA[&&]]>
<acroref type="definition" acro="RREF" />
\\
<![CDATA[&=\sum_{k=1}^{m}\delta_{1k}\matrixentry{C}{kd_1}\\]]>
<![CDATA[&=\sum_{k=1}^{m}\delta_{1k}(0)]]>
<![CDATA[&&d_1<d^\prime_1\\]]>
<![CDATA[&=0]]>
</alignmath>
The entries of $C$ are all zero since they are left and below of the leading 1 in row 1 and column $d^\prime_1$ of $C$.  This is a contradiction, so we know that $d_1\geq d^\prime_1$.  By an entirely similar argument, reversing the roles of $B$ and $C$, we could conclude that $d_1\leq d^\prime_1$.  Together this means that $d_1=d^\prime_1$.</p>

<p>Second Step.  Suppose that we have determined that $d_1=d^\prime_1$, $d_2=d^\prime_2$, $d_3=d^\prime_3$, <ellipsis />
 $d_p=d^\prime_p$.  Let us now show that $d_{p+1}=d^\prime_{p+1}$.  Working towards a contradiction, suppose that $d_{p+1}\lt d^\prime_{p+1}$.  For $1\leq\ell\leq p$,
<alignmath>
0
<![CDATA[&=\matrixentry{B}{p+1,d_\ell}]]>
<![CDATA[&&]]>
<acroref type="definition" acro="RREF" />
\\
<![CDATA[&=\sum_{k=1}^{m}\delta_{p+1,k}\matrixentry{C}{kd_\ell}\\]]>
<![CDATA[&=\sum_{k=1}^{m}\delta_{p+1,k}\matrixentry{C}{kd^\prime_\ell}\\]]>
<![CDATA[&=]]>
\delta_{p+1,\ell}\matrixentry{C}{\ell d^\prime_\ell}+ \sum_{\substack{k=1\\k\neq\ell}}^{m}\delta_{p+1,k}\matrixentry{C}{kd^\prime_\ell}
<![CDATA[&&]]>
<acroref type="property" acro="CACN" />
\\
<![CDATA[&=]]> \delta_{p+1,\ell}(1)+ \sum_{\substack{k=1\\k\neq\ell}}^{m}\delta_{p+1,k}(0)
<![CDATA[&&]]>
<acroref type="definition" acro="RREF" />
\\
<![CDATA[&=\delta_{p+1,\ell}]]>
</alignmath>
Now,
<alignmath>
1
<![CDATA[&=\matrixentry{B}{p+1,d_{p+1}}]]>
<![CDATA[&&]]>
<acroref type="definition" acro="RREF" />
\\
<![CDATA[&=\sum_{k=1}^{m}\delta_{p+1,k}\matrixentry{C}{kd_{p+1}}\\]]>
<![CDATA[&=]]> \sum_{k=1}^{p}\delta_{p+1,k}\matrixentry{C}{kd_{p+1}}+ \sum_{k=p+1}^{m}\delta_{p+1,k}\matrixentry{C}{kd_{p+1}}
<![CDATA[&&]]>
<acroref type="property" acro="AACN" />
\\
<![CDATA[&=]]> \sum_{k=1}^{p}(0)\matrixentry{C}{kd_{p+1}}+ \sum_{k=p+1}^{m}\delta_{p+1,k}\matrixentry{C}{kd_{p+1}}\\
<![CDATA[&=\sum_{k=p+1}^{m}\delta_{p+1,k}\matrixentry{C}{kd_{p+1}}\\]]>
<![CDATA[&=\sum_{k=p+1}^{m}\delta_{p+1,k}(0)]]>
<![CDATA[&&d_{p+1}<d^\prime_{p+1}\\]]>
<![CDATA[&=0]]>
</alignmath>
This contradiction shows that
$d_{p+1}\geq d^\prime_{p+1}$.  By an entirely similar argument, we could conclude that $d_{p+1}\leq d^\prime_{p+1}$, and therefore $d_{p+1}=d^\prime_{p+1}$.</p>

<p>
Third Step.  Now we establish that $r=r^\prime$.  Suppose that $r^\prime\lt r$.  By the arguments above, we know that $d_1=d^\prime_1$, $d_2=d^\prime_2$, $d_3=d^\prime_3$, <ellipsis />
, $d_{r^\prime}=d^\prime_{r^\prime}$.   For $1\leq\ell\leq r^\prime\lt r$,
<alignmath>
0
<![CDATA[&=\matrixentry{B}{rd_\ell}]]>
<![CDATA[&&]]>
<acroref type="definition" acro="RREF" />
\\
<![CDATA[&=\sum_{k=1}^{m}\delta_{rk}\matrixentry{C}{kd_\ell}\\]]>
<![CDATA[&=]]> \sum_{k=1}^{r^\prime}\delta_{rk}\matrixentry{C}{kd_\ell} + \sum_{k=r^\prime+1}^{m}\delta_{rk}\matrixentry{C}{kd_\ell}
<![CDATA[&&]]>
<acroref type="property" acro="AACN" />
\\%
<![CDATA[&=]]> \sum_{k=1}^{r^\prime}\delta_{rk}\matrixentry{C}{kd_\ell} + \sum_{k=r^\prime+1}^{m}\delta_{rk}(0)
<![CDATA[&&]]>
<acroref type="property" acro="AACN" />
\\
<![CDATA[&=\sum_{k=1}^{r^\prime}\delta_{rk}\matrixentry{C}{kd_\ell}\\]]>
<![CDATA[&=\sum_{k=1}^{r^\prime}\delta_{rk}\matrixentry{C}{kd^\prime_\ell}\\]]>
<![CDATA[&=]]>
\delta_{r\ell}\matrixentry{C}{\ell d^\prime_\ell} + \sum_{\substack{k=1\\k\neq\ell}}^{r^\prime}\delta_{rk}\matrixentry{C}{kd^\prime_\ell}
<![CDATA[&&]]>
<acroref type="property" acro="CACN" />
\\
<![CDATA[&=]]> \delta_{r\ell}(1) + \sum_{\substack{k=1\\k\neq\ell}}^{r^\prime}\delta_{rk}(0)
<![CDATA[&&]]>
<acroref type="definition" acro="RREF" />
\\
<![CDATA[&=\delta_{r\ell}]]>
</alignmath>
Now examine the entries of row $r$ of $B$,
<alignmath>
\matrixentry{B}{rj}
<![CDATA[&=\sum_{k=1}^{m}\delta_{rk}\matrixentry{C}{kj}\\]]>
<![CDATA[&=]]> \sum_{k=1}^{r^\prime}\delta_{rk}\matrixentry{C}{kj} + \sum_{k=r^\prime+1}^{m}\delta_{rk}\matrixentry{C}{kj}
<![CDATA[&&]]>
<acroref type="property" acro="CACN" />
\\
<![CDATA[&=]]> \sum_{k=1}^{r^\prime}\delta_{rk}\matrixentry{C}{kj} + \sum_{k=r^\prime+1}^{m}\delta_{rk}(0)
<![CDATA[&&]]>
<acroref type="definition" acro="RREF" />
\\
<![CDATA[&=\sum_{k=1}^{r^\prime}\delta_{rk}\matrixentry{C}{kj}\\]]>
<![CDATA[&=\sum_{k=1}^{r^\prime}(0)\matrixentry{C}{kj}\\]]>
<![CDATA[&=0]]>
</alignmath>
So row $r$ is a totally zero row, contradicting that this should be the bottommost nonzero row of $B$.  So $r^\prime\geq r$.  By an entirely similar argument, reversing the roles of $B$ and $C$, we would conclude that $r^\prime\leq r$ and therefore $r=r^\prime$.  Thus, combining the first three steps we can say that $D=D^\prime$.  In other words, $B$ and $C$ have the same pivot columns, in the same locations.</p>

<p>
Fourth Step.  In this final step, we will not argue by contradiction.  Our intent is to determine the values of the $\delta_{ij}$.  Notice that we can use the values of the $d_i$ interchangeably for $B$ and $C$.  Here we go,
<alignmath>
1
<![CDATA[&=\matrixentry{B}{id_i}]]>
<![CDATA[&&]]>
<acroref type="definition" acro="RREF" />
\\
<![CDATA[&=\sum_{k=1}^{m}\delta_{ik}\matrixentry{C}{kd_i}\\]]>
<![CDATA[&=]]> \delta_{ii}\matrixentry{C}{id_i} + \sum_{\substack{k=1\\k\neq i}}^{m}\delta_{ik}\matrixentry{C}{kd_i}
<![CDATA[&&]]>
<acroref type="property" acro="CACN" />
\\
<![CDATA[&=]]> \delta_{ii}(1) + \sum_{\substack{k=1\\k\neq i}}^{m}\delta_{ik}(0)
<![CDATA[&&]]>
<acroref type="definition" acro="RREF" />
\\
<![CDATA[&=\delta_{ii}]]>
</alignmath>
and for $\ell\neq i$
<alignmath>
0
<![CDATA[&=\matrixentry{B}{id_\ell}]]>
<![CDATA[&&]]>
<acroref type="definition" acro="RREF" />
\\
<![CDATA[&=\sum_{k=1}^{m}\delta_{ik}\matrixentry{C}{kd_\ell}\\]]>
<![CDATA[&=]]>
\delta_{i\ell}\matrixentry{C}{\ell d_\ell} + \sum_{\substack{k=1\\k\neq\ell}}^{m}\delta_{ik}\matrixentry{C}{kd_\ell}
<![CDATA[&&]]>
<acroref type="property" acro="CACN" />
\\
<![CDATA[&=]]> \delta_{i\ell}(1) + \sum_{\substack{k=1\\k\neq\ell}}^{m}\delta_{ik}(0)
<![CDATA[&&]]>
<acroref type="definition" acro="RREF" />
\\
<![CDATA[&=\delta_{i\ell}]]>
</alignmath>
Finally, having determined the values of the $\delta_{ij}$, we can show that $B=C$.  For $1\leq i\leq m$, $1\leq j\leq n$,
<alignmath>
\matrixentry{B}{ij}
<![CDATA[&=\sum_{k=1}^{m}\delta_{ik}\matrixentry{C}{kj}\\]]>
<![CDATA[&=]]> \delta_{ii}\matrixentry{C}{ij} + \sum_{\substack{k=1\\k\neq i}}^{m}\delta_{ik}\matrixentry{C}{kj}
<![CDATA[&&]]>
<acroref type="property" acro="CACN" />
\\
<![CDATA[&=]]> (1)\matrixentry{C}{ij} + \sum_{\substack{k=1\\k\neq i}}^{m}(0)\matrixentry{C}{kj}\\
<![CDATA[&=\matrixentry{C}{ij}]]>
</alignmath>
So $B$ and $C$ have equal values in every entry, and so are the same matrix.</p>

</proof>
</theorem>

<p>We will now run through some examples of using these definitions and theorems to solve some systems of equations.  From now on, when we have a matrix in reduced row-echelon form, we will mark the leading 1's with a small box.  This will help you count, and identify, the pivot columns.  In your work, you can box 'em, circle 'em or write 'em in a different color <mdash />
 just identify 'em somehow.  This device will prove very useful later and is a <em>very good habit</em> to start developing <em>right now</em>.
</p>

<example acro="SAB" index="archetype B!solutions">
<title>Solutions for Archetype B</title>

<p>Let us find the solutions to the following system of equations,
<archetypepart acro="B" part="systemdefn" />
First, form the augmented matrix,
<alignmath>
<archetypepart acro="B" part="augmented" />
</alignmath>
and work to reduced row-echelon form, first with $j=1$,
<alignmath>
\xrightarrow{\rowopswap{1}{3}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[1&0&4&5\\]]>
<![CDATA[5&5&7&24\\]]>
<![CDATA[-7&-6&-12&-33]]>
\end{bmatrix}
\xrightarrow{\rowopadd{-5}{1}{2}}
\begin{bmatrix}
<![CDATA[1&0&4&5\\]]>
<![CDATA[0&5&-13&-1\\]]>
<![CDATA[-7&-6&-12&-33]]>
\end{bmatrix}\\
\xrightarrow{\rowopadd{7}{1}{3}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[\leading{1}&0&4&5\\]]>
<![CDATA[0&5&-13&-1\\]]>
<![CDATA[0&-6&16&2]]>
\end{bmatrix}
<intertext>Now, with $j=2$,</intertext>
\xrightarrow{\rowopmult{\frac{1}{5}}{2}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[\leading{1}&0&4&5\\]]>
<![CDATA[0&1&\frac{-13}{5}&\frac{-1}{5}\\]]>
<![CDATA[0&-6&16&2]]>
\end{bmatrix}
\xrightarrow{\rowopadd{6}{2}{3}}
\begin{bmatrix}
<![CDATA[\leading{1}&0&4&5\\]]>
<![CDATA[0&\leading{1}&\frac{-13}{5}&\frac{-1}{5}\\]]>
<![CDATA[0&0&\frac{2}{5}&\frac{4}{5}]]>
\end{bmatrix}
<intertext>And finally, with $j=3$,</intertext>
\xrightarrow{\rowopmult{\frac{5}{2}}{3}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[\leading{1}&0&4&5\\]]>
<![CDATA[0&\leading{1}&\frac{-13}{5}&\frac{-1}{5}\\]]>
<![CDATA[0&0&1&2]]>
\end{bmatrix}
\xrightarrow{\rowopadd{\frac{13}{5}}{3}{2}}
\begin{bmatrix}
<![CDATA[\leading{1}&0&4&5\\]]>
<![CDATA[0&\leading{1}&0&5\\]]>
<![CDATA[0&0&1&2]]>
\end{bmatrix}\\
\xrightarrow{\rowopadd{-4}{3}{1}}
<![CDATA[&]]>
<archetypepart acro="B" part="augmentedreduced" />
</alignmath>
</p>

<p>This is now the augmented matrix of a very simple system of equations, namely $x_1=-3$, $x_2=5$, $x_3=2$, which has an obvious solution.  Furthermore, we can see that this is the <em>only</em> solution to this system, so we have determined the entire solution set,
<alignmath>
<![CDATA[S&=\set{\colvector{-3\\5\\2}}]]>
</alignmath>
</p>

<p>You might compare this example with the procedure we used in <acroref type="example" acro="US" />
.</p>

</example>

<p>Archetypes A and B are meant to contrast each other in many respects.  So let us solve Archetype A now.</p>

<example acro="SAA" index="solution set!Archetype A">
<title>Solutions for Archetype A</title>

<p>Let us find the solutions to the following system of equations,
<archetypepart acro="A" part="systemdefn" />
</p>

<p>First, form the augmented matrix,
<alignmath>
<archetypepart acro="A" part="augmented" />
</alignmath>
and work to reduced row-echelon form, first with $j=1$,
<alignmath>
\xrightarrow{\rowopadd{-2}{1}{2}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[1 & -1 & 2 & 1\\]]>
<![CDATA[0 & 3 & -3 & 6\\]]>
<![CDATA[1 & 1 & 0 & 5]]>
\end{bmatrix}
\xrightarrow{\rowopadd{-1}{1}{3}}
\begin{bmatrix}
<![CDATA[\leading{1} & -1 & 2 & 1\\]]>
<![CDATA[0 & 3 & -3 & 6\\]]>
<![CDATA[0 & 2 & -2 & 4]]>
\end{bmatrix}
<intertext>Now, with $j=2$,</intertext>
\xrightarrow{\rowopmult{\frac{1}{3}}{2}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[\leading{1} & -1 & 2 & 1\\]]>
<![CDATA[0 & 1 & -1 & 2\\]]>
<![CDATA[0 & 2 & -2 & 4]]>
\end{bmatrix}
\xrightarrow{\rowopadd{1}{2}{1}}
\begin{bmatrix}
<![CDATA[\leading{1} & 0 & 1 & 3\\]]>
<![CDATA[0 & 1 & -1 & 2\\]]>
<![CDATA[0 & 2 & -2 & 4]]>
\end{bmatrix}\\
\xrightarrow{\rowopadd{-2}{2}{3}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[\leading{1} & 0 & 1 & 3\\]]>
<![CDATA[0 & \leading{1} & -1 & 2\\]]>
<![CDATA[0 & 0 & 0 & 0]]>
\end{bmatrix}
</alignmath>
</p>

<p>The system of equations represented by this augmented matrix needs to be considered a bit differently than that for Archetype B.  First, the last row of the matrix is the equation $0=0$, which is <em>always</em> true, so it imposes no restrictions on our possible solutions and therefore we can safely ignore it as we analyze the other two equations.  These equations are,
<alignmath>
<![CDATA[x_1+x_3&=3\\]]>
<![CDATA[x_2-x_3&=2.]]>
</alignmath>
</p>

<p>While this system is fairly easy to solve, it also appears to have a multitude of solutions.  For example, choose $x_3=1$ and see that then $x_1=2$ and $x_2=3$ will together form a solution.  Or choose $x_3=0$, and then discover that $x_1=3$ and $x_2=2$ lead to a solution.  Try it yourself: pick <em>any</em> value of $x_3$ you please, and figure out what $x_1$ and $x_2$ should be to make the first and second equations (respectively) true.  We'll wait while you do that.  Because of this behavior, we say that $x_3$ is a <q>free</q> or <q>independent</q> variable.  But why do we vary $x_3$ and not some other variable?  For now, notice that the third column of the augmented matrix is not a pivot column.  With this idea, we can rearrange the two equations, solving each for the variable whose index is the same as the column index of a pivot column.
<alignmath>
<![CDATA[x_1&=3-x_3\\]]>
<![CDATA[x_2&=2+x_3]]>
</alignmath>
</p>

<p>To write the set of solution vectors in set notation, we have
<alignmath>
<![CDATA[S&=\setparts{\colvector{3-x_3\\2+x_3\\x_3}}{x_3\in\complex{\null}}]]>
</alignmath>
</p>

<p>We will learn more in the next section about systems with infinitely many solutions and how to express their solution sets.  Right now, you might look back at  <acroref type="example" acro="IS" />
.</p>

</example>

<example acro="SAE" index="solution set!archetype E">
<title>Solutions for Archetype E</title>

<p>Let us find the solutions to the following system of equations,
<archetypepart acro="E" part="systemdefn" />
</p>

<p>First, form the augmented matrix,
<alignmath>
<archetypepart acro="E" part="augmented" />
</alignmath>
and work to reduced row-echelon form, first with $j=1$,
<alignmath>
\xrightarrow{\rowopswap{1}{3}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[1 & 1 & 4 &  -5 & 2\\]]>
<![CDATA[-3 & 4 &  -5 & -6 &  3\\]]>
<![CDATA[2 & 1 & 7 & -7 & 2]]>
\end{bmatrix}
\xrightarrow{\rowopadd{3}{1}{2}}
\begin{bmatrix}
<![CDATA[1 & 1 & 4 &  -5 & 2\\]]>
<![CDATA[0 & 7 &  7 & -21 &  9\\]]>
<![CDATA[2 & 1 & 7 & -7 & 2]]>
\end{bmatrix}\\
\xrightarrow{\rowopadd{-2}{1}{3}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[\leading{1} & 1 & 4 &  -5 & 2\\]]>
<![CDATA[0 & 7 &  7 & -21 &  9\\]]>
<![CDATA[0 & -1 & -1 & 3 & -2]]>
\end{bmatrix}
<intertext>Now, with $j=2$,</intertext>
\xrightarrow{\rowopswap{2}{3}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[\leading{1} & 1 & 4 &  -5 & 2\\]]>
<![CDATA[0 & -1 & -1 & 3 & -2\\]]>
<![CDATA[0 & 7 &  7 & -21 &  9]]>
\end{bmatrix}
\xrightarrow{\rowopmult{-1}{2}}
\begin{bmatrix}
<![CDATA[\leading{1} & 1 & 4 &  -5 & 2\\]]>
<![CDATA[0 & 1 & 1 & -3 & 2\\]]>
<![CDATA[0 & 7 &  7 & -21 &  9]]>
\end{bmatrix}\\
\xrightarrow{\rowopadd{-1}{2}{1}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[\leading{1} & 0 & 3 &  -2 & 0\\]]>
<![CDATA[0 & 1 & 1 & -3 & 2\\]]>
<![CDATA[0 & 7 &  7 & -21 &  9]]>
\end{bmatrix}
\xrightarrow{\rowopadd{-7}{2}{3}}
\begin{bmatrix}
<![CDATA[\leading{1} & 0 & 3 &  -2 & 0\\]]>
<![CDATA[0 & \leading{1} & 1 & -3 & 2\\]]>
<![CDATA[0 & 0 &  0 & 0 &  -5]]>
\end{bmatrix}
<intertext>And finally, with $j=4$,</intertext>
\xrightarrow{\rowopmult{-\frac{1}{5}}{3}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[\leading{1} & 0 & 3 &  -2 & 0\\]]>
<![CDATA[0 & \leading{1} & 1 & -3 & 2\\]]>
<![CDATA[0 & 0 &  0 & 0 &  1]]>
\end{bmatrix}
\xrightarrow{\rowopadd{-2}{3}{2}}
<archetypepart acro="E" part="augmentedreduced" />
</alignmath>
</p>

<p>Let us analyze the equations in the system represented by this augmented matrix.  The third equation will read $0=1$.  This is patently false, all the time.  No choice of values for our variables will ever make it true.  We are done.  Since we cannot even make the last equation true, we have no hope of making all of the equations simultaneously true.  So this system has no solutions, and its solution set is the empty set, $\emptyset=\set{\ }$ (<acroref type="definition" acro="ES" />
).</p>

<p>Notice that we could have reached this conclusion sooner.  After performing the row operation
$\rowopadd{-7}{2}{3}$, we can see that the third equation reads $0=-5$, a false statement.  Since the system represented by this matrix has no solutions, none of the systems represented has any solutions.  However, for this example, we have chosen to bring the matrix all the way  to reduced row-echelon form as practice.</p>

</example>

<p>These three examples
(<acroref type="example" acro="SAB" />
,<acroref type="example" acro="SAA" />
,<acroref type="example" acro="SAE" />
)
illustrate the full range of possibilities for a system of linear equations <mdash />
 no solutions, one solution, or infinitely many solutions.  In the next section we will examine these three scenarios more closely.</p>

<p>We (and everybody else) will often speak of <q>row-reducing</q> a matrix.  This is an informal way of saying we begin with a matrix $A$ and then analyze <em>the</em> matrix $B$ that is row-equivalent to $A$ and in reduced row-echelon form.  So the term <define>row-reduce</define> is used as a verb, but describes something a bit more complicated, since we do not really change $A$.   <acroref type="theorem" acro="REMEF" />
 tells us that this process will always be successful and <acroref type="theorem" acro="RREFU" />
 tells us that $B$ will be unambiguous.  Typically, an investigation of $A$ will proceed by analyzing $B$ and applying theorems whose hypotheses include the row-equivalence of $A$ and $B$, and usually the hypothesis that $B$ is in reduced row-echelon form.</p>

<sageadvice acro="RREF" index="reduced row-echelon form">
<title>Reduced Row-Echelon Form</title>

<p>There has been a lot of information about using Sage with vectors and matrices in this section.  But we can now construct the coefficient matrix of a system of equations and the vector of constants.  From these pieces we can easily construct the augmented matrix, which we could subject to a series of row operations.  Computers are suppose to make routine tasks easy so we can concentrate on bigger ideas.  No exception here, Sage can bring a matrix (augmented or not) to reduced row echelon form with no problem.  Let us redo <acroref type="example" acro="SAB" />
 with Sage.</p>

<sage>
<input>coeff = matrix(QQ, [[-7, -6, -12],
                    [5,   5,   7],
                    [1,   0,   4]])
const = vector(QQ, [-33, 24, 5])
aug = coeff.augment(const)
aug.rref()
</input>
<output>[ 1  0  0 -3]
[ 0  1  0  5]
[ 0  0  1  2]
</output>
</sage>

<p>And the solution $x_1=-3$, $x_2=5$, $x_3=2$ is now obvious.  Beautiful.</p>

<p>You may notice that Sage has some commands with the word <q>echelon</q> in them.  For now, these should be avoided like the plague, as there are some subtleties in how they work.  The matrix method <code>.rref()</code> will be sufficient for our purposes for a long, long time <mdash />
 so stick with it.</p>

</sageadvice>
</subsection>

<!--   End  rref.tex -->
<readingquestions>
<ol>
<li>Is the matrix below in reduced row-echelon form?  Why or why
not?
<equation>
\begin{bmatrix}
<![CDATA[1 & 5 & 0 & 6 & 8\\]]>
<![CDATA[0 & 0 & 1 & 2 & 0\\]]>
<![CDATA[0 & 0 & 0 & 0 & 1]]>
\end{bmatrix}
</equation>
</li>
<li>Use row operations to convert the matrix below to reduced
row-echelon form and report the final matrix.
<equation>
\begin{bmatrix}
<![CDATA[2 & 1 & 8\\]]>
<![CDATA[-1 & 1 & -1\\]]>
<![CDATA[-2 & 5 & 4]]>
\end{bmatrix}
</equation>
</li>
<li>Find all the solutions to the system below by using an augmented
matrix and row operations.  Report your final matrix in reduced row-echelon form and the set of solutions.
<alignmath>
<![CDATA[2x_1 + 3x_2 - x_3&= 0\\]]>
<![CDATA[x_1 + 2x_2 + x_3&= 3\\]]>
<![CDATA[x_1 + 3x_2 + 3x_3&= 7]]>
</alignmath>
</li>
</ol>
</readingquestions>

<exercisesubsection>

<exercise type="C" number="05" rough=" row-reduce all archetypes">
<problem contributor="robertbeezer">Each archetype below is a system of equations.  Form the augmented matrix of the system of equations, convert the matrix to reduced row-echelon form by using equation operations and then describe the solution set of the original system of equations.<br />
<br />
<acroref type="archetype" acro="A" />
,
<acroref type="archetype" acro="B" />
,
<acroref type="archetype" acro="C" />
,
<acroref type="archetype" acro="D" />
,
<acroref type="archetype" acro="E" />
,
<acroref type="archetype" acro="F" />
,
<acroref type="archetype" acro="G" />
,
<acroref type="archetype" acro="H" />
,
<acroref type="archetype" acro="I" />
,
<acroref type="archetype" acro="J" />
</problem>
</exercise>

<exercisegroup>
<p>For problems C10<ndash />
C19, find all solutions to the system of linear equations.  Use your favorite computing device to row-reduce the augmented matrices for the systems, and write the solutions as a set, using correct set notation.</p>

<exercise type="C" number="10" rough=" 4x4 system, unique solution">
<problem contributor="robertbeezer">
<alignmath>
<![CDATA[2x_1-3x_2+x_3+7x_4&=14\\]]>
<![CDATA[2x_1+8x_2-4x_3+5x_4&=-1\\]]>
<![CDATA[x_1+3x_2-3x_3&=4 \\]]>
<![CDATA[-5x_1+2x_2+3x_3+4x_4&=-19]]>
</alignmath>
</problem>
<solution contributor="robertbeezer">The augmented matrix row-reduces to
<equation>
\begin{bmatrix}
<![CDATA[\leading{1} &  0 &  0 &  0 &  1\\]]>
<![CDATA[0 &  \leading{1} &  0 &  0 &  -3\\]]>
<![CDATA[0 &  0 &  \leading{1} &  0 &  -4\\]]>
<![CDATA[0 &  0 &  0 &  \leading{1} &  1]]>
\end{bmatrix}
</equation>
This augmented matrix represents the linear system $x_1=1$, $x_2=-3$, $x_3=-4$, $x_4=1$, which clearly has only one possible solution.  We can write this solution set then as
<alignmath>
<![CDATA[S&=\set{\colvector{1\\-3\\-4\\1}}]]>
</alignmath>
</solution>
</exercise>

<exercise type="C" number="11" rough=" 3x4 system, inconsistent">
<problem contributor="robertbeezer">
<alignmath>
<![CDATA[3x_1+4x_2-x_3+2x_4&=6\\]]>
<![CDATA[x_1-2x_2+3x_3+x_4&=2\\]]>
<![CDATA[10x_2-10x_3-x_4&=1]]>
</alignmath>
</problem>
<solution contributor="robertbeezer">The augmented matrix row-reduces to
<equation>
\begin{bmatrix}
<![CDATA[\leading{1} &  0 &  1 &  4/5 &  0\\]]>
<![CDATA[0 &  \leading{1} &  -1 &  -1/10 &  0\\]]>
<![CDATA[0 &  0 &  0 &  0 &  \leading{1}]]>
\end{bmatrix}
</equation>
Row 3 represents the equation $0=1$, which is patently false, so the original system has no solutions.  We can express the solution set as the empty set, $\emptyset=\set{\ }$.
</solution>
</exercise>

<exercise type="C" number="12" rough=" 3x4 system, 2 free variables">
<problem contributor="robertbeezer">
<alignmath>
<![CDATA[2x_1+4x_2+5x_3+7x_4&=-26\\]]>
<![CDATA[x_1+2x_2+x_3-x_4&=-4\\]]>
<![CDATA[-2x_1-4x_2+x_3+11x_4&=-10]]>
</alignmath>
</problem>
<solution contributor="robertbeezer">The augmented matrix row-reduces to
<alignmath>
\begin{bmatrix}
<![CDATA[\leading{1} &  2 &  0 &  -4 &  2\\]]>
<![CDATA[0 &  0 &  \leading{1} &  3 &  -6\\]]>
<![CDATA[0 &  0 &  0 &  0 &  0]]>
\end{bmatrix}
</alignmath>
In the spirit of <acroref type="example" acro="SAA" />
, we can express the infinitely many solutions of this system compactly with set notation.  The key is to express certain variables in terms of others.  More specifically, each pivot column number is the index of a variable that can be written in terms of the variables whose indices are non-pivot columns.  Or saying the same thing: for each $i$ in $D$, we can find an expression for $x_i$ in terms of the variables without their index in $D$.  Here $D=\set{1,\,3}$, so
<alignmath>
<![CDATA[x_1&=2-2x_2+4x_4\\]]>
<![CDATA[x_3&=-6\quad\quad-3x_4]]>
</alignmath>
As a set, we write the solutions precisely as
<alignmath>
\setparts{\colvector{2-2x_2+4x_4\\x_2\\-6-3x_4\\x_4}}{x_2,\,x_4\in\complex{\null}}
</alignmath>
</solution>
</exercise>

<exercise type="C" number="13" rough=" 3x4 system, inconsistent">
<problem contributor="robertbeezer">
<alignmath>
<![CDATA[x_1+2x_2+8x_3-7x_4&=-2\\]]>
<![CDATA[3x_1+2x_2+12x_3-5x_4&=6\\]]>
<![CDATA[-x_1+x_2+x_3-5x_4&=-10]]>
</alignmath>
</problem>
<solution contributor="robertbeezer">The augmented matrix of the system of equations is
<equation>
\begin{bmatrix}
<![CDATA[1 & 2 & 8 & -7 & -2\\]]>
<![CDATA[3 & 2 & 12 & -5 & 6\\]]>
<![CDATA[-1 & 1 & 1 & -5 & -10]]>
\end{bmatrix}
</equation>
which row-reduces to
<equation>
\begin{bmatrix}
<![CDATA[\leading{1} & 0 & 2 & 1 & 0\\]]>
<![CDATA[0 & \leading{1} & 3 & -4 & 0\\]]>
<![CDATA[0 & 0 & 0 & 0 & \leading{1}]]>
\end{bmatrix}
</equation>
Row 3 represents the equation $0=1$, which is patently false, so the original system has no solutions.  We can express the solution set as the empty set, $\emptyset=\set{\ }$.
</solution>
</exercise>

<exercise type="C" number="14" rough=" 3x4 system, 2 free variables">
<problem contributor="robertbeezer">
<alignmath>
<![CDATA[2x_1+x_2+7x_3-2x_4&=4\\]]>
<![CDATA[3x_1-2x_2+11x_4&=13\\]]>
<![CDATA[x_1+x_2+5x_3-3x_4&=1]]>
</alignmath>
</problem>
<solution contributor="robertbeezer">The augmented matrix of the system of equations is
<equation>
\begin{bmatrix}
<![CDATA[2 & 1 & 7 & -2 & 4\\]]>
<![CDATA[3 & -2 & 0 & 11 & 13\\]]>
<![CDATA[1 & 1 & 5 & -3 & 1]]>
\end{bmatrix}
</equation>
which row-reduces to
<equation>
\begin{bmatrix}
<![CDATA[\leading{1}& 0 & 2 & 1 & 3\\]]>
<![CDATA[0 & \leading{1} & 3 & -4 & -2\\]]>
<![CDATA[0 & 0 & 0 & 0 & 0]]>
\end{bmatrix}
</equation>
In the spirit of <acroref type="example" acro="SAA" />
, we can express the infinitely many solutions of this system compactly with set notation.  The key is to express certain variables in terms of others.  More specifically, each pivot column number is the index of a variable that can be written in terms of the variables whose indices are non-pivot columns.  Or saying the same thing: for each $i$ in $D$, we can find an expression for $x_i$ in terms of the variables without their index in $D$.  Here $D=\set{1,\,2}$, so rearranging the equations represented by the two nonzero rows to gain expressions for the variables $x_1$ and $x_2$ yields the solution set,
<equation> S=\setparts{
\colvector{3-2x_3-x_4\\-2-3x_3+4x_4\\x_3\\x_4}
}{
x_3,\,x_4\in\complex{\null}
}
</equation>
</solution>
</exercise>

<exercise type="C" number="15" rough=" 3x4 system, 1 free variable">
<problem contributor="robertbeezer">
<alignmath>
<![CDATA[2x_1+ 3x_2-x_3 -9x_4&=-16\\]]>
<![CDATA[x_1+ 2x_2+ x_3&=0\\]]>
<![CDATA[-x_1+ 2x_2+ 3x_3+ 4x_4&=8]]>
</alignmath>
</problem>
<solution contributor="robertbeezer">The augmented matrix of the system of equations is
<equation>
\begin{bmatrix}
<![CDATA[ 2 & 3 & -1 & -9 & -16 \\]]>
<![CDATA[ 1 & 2 & 1 & 0 & 0 \\]]>
<![CDATA[ -1 & 2 & 3 & 4 & 8]]>
\end{bmatrix}
</equation>
which row-reduces to
<equation>
\begin{bmatrix}
<![CDATA[ \leading{1} & 0 & 0 & 2 & 3 \\]]>
<![CDATA[ 0 & \leading{1} & 0 & -3 & -5 \\]]>
<![CDATA[ 0 & 0 & \leading{1} & 4 & 7]]>
\end{bmatrix}
</equation>
In the spirit of <acroref type="example" acro="SAA" />
, we can express the infinitely many solutions of this system compactly with set notation.  The key is to express certain variables in terms of others.  More specifically, each pivot column number is the index of a variable that can be written in terms of the variables whose indices are non-pivot columns.  Or saying the same thing: for each $i$ in $D$, we can find an expression for $x_i$ in terms of the variables without their index in $D$.  Here $D=\set{1,\,2,\,3}$, so rearranging the equations represented by the three nonzero rows to gain expressions for the variables $x_1$, $x_2$ and $x_3$ yields the solution set,
<equation> S=\setparts{
\colvector{3-2x_4\\-5+3x_4\\7-4x_4\\x_4}
}{
x_4\in\complex{\null}
}
</equation>
</solution>
</exercise>

<exercise type="C" number="16" rough=" 3x4 system, inconsistent">
<problem contributor="robertbeezer">
<alignmath>
<![CDATA[2x_1+ 3x_2+19x_3 -4x_4&=2\\]]>
<![CDATA[x_1+ 2x_2+ 12x_3-3x_4&=1\\]]>
<![CDATA[-x_1+ 2x_2+ 8x_3-5x_4&=1]]>
</alignmath>
</problem>
<solution contributor="robertbeezer">The augmented matrix of the system of equations is
<equation>
\begin{bmatrix}
<![CDATA[ 2 & 3 & 19 & -4 & 2 \\]]>
<![CDATA[ 1 & 2 & 12 & -3 & 1 \\]]>
<![CDATA[ -1 & 2 & 8 & -5 & 1]]>
\end{bmatrix}
</equation>
which row-reduces to
<equation>
\begin{bmatrix}
<![CDATA[ \leading{1} & 0 & 2 & 1 & 0 \\]]>
<![CDATA[ 0 & \leading{1} & 5 & -2 & 0 \\]]>
<![CDATA[ 0 & 0 & 0 & 0 & \leading{1}]]>
\end{bmatrix}
</equation>
Row 3 represents the equation $0=1$, which is patently false, so the original system has no solutions.  We can express the solution set as the empty set, $\emptyset=\set{\ }$.
</solution>
</exercise>

<exercise type="C" number="17" rough=" 4x4 system, unique">
<problem contributor="robertbeezer">
<alignmath>
<![CDATA[-x_1+5x_2&=-8\\]]>
<![CDATA[-2x_1+5x_2+5x_3+2x_4&=9\\]]>
<![CDATA[-3x_1-x_2+3x_3+x_4&=3\\]]>
<![CDATA[7x_1+6x_2+5x_3+x_4&=30]]>
</alignmath>
</problem>
<solution contributor="robertbeezer">We row-reduce the augmented matrix of the system of equations,
<alignmath>
\begin{bmatrix}
<![CDATA[ -1 & 5 & 0 & 0 & -8 \\]]>
<![CDATA[ -2 & 5 & 5 & 2 & 9 \\]]>
<![CDATA[ -3 & -1 & 3 & 1 & 3 \\]]>
<![CDATA[ 7 & 6 & 5 & 1 & 30]]>
\end{bmatrix}
<![CDATA[&\rref]]>
\begin{bmatrix}
<![CDATA[ \leading{1} & 0 & 0 & 0 & 3 \\]]>
<![CDATA[ 0 & \leading{1} & 0 & 0 & -1 \\]]>
<![CDATA[ 0 & 0 & \leading{1} & 0 & 2 \\]]>
<![CDATA[ 0 & 0 & 0 & \leading{1} & 5]]>
\end{bmatrix}
</alignmath>
This augmented matrix represents the linear system $x_1=3$, $x_2=-1$, $x_3=2$, $x_4=5$, which clearly has only one possible solution.  We can write this solution set then as
<alignmath>
<![CDATA[S&=\set{\colvector{3\\-1\\2\\5}}]]>
</alignmath>
</solution>
</exercise>

<exercise type="C" number="18" rough=" 3x5 system, 2 free variables">
<problem contributor="robertbeezer">
<alignmath>
<![CDATA[x_1+2x_2-4x_3-x_4&=32\\]]>
<![CDATA[x_1+3x_2-7x_3-x_5&=33\\]]>
<![CDATA[x_1+2x_3-2x_4+3x_5&=22\\]]>
</alignmath>
</problem>
<solution contributor="robertbeezer">We row-reduce the augmented matrix of the system of equations,
<alignmath>
\begin{bmatrix}
<![CDATA[ 1 & 2 & -4 & -1 & 0 & 32 \\]]>
<![CDATA[ 1 & 3 & -7 & 0 & -1 & 33 \\]]>
<![CDATA[ 1 & 0 & 2 & -2 & 3 & 22]]>
\end{bmatrix}
<![CDATA[&\rref]]>
\begin{bmatrix}
<![CDATA[ \leading{1} & 0 & 2 & 0 & 5 & 6 \\]]>
<![CDATA[ 0 & \leading{1} & -3 & 0 & -2 & 9 \\]]>
<![CDATA[ 0 & 0 & 0 & \leading{1} & 1 & -8]]>
\end{bmatrix}
</alignmath>
In the spirit of <acroref type="example" acro="SAA" />
, we can express the infinitely many solutions of this system compactly with set notation.  The key is to express certain variables in terms of others.  More specifically, each pivot column number is the index of a variable that can be written in terms of the variables whose indices are non-pivot columns.  Or saying the same thing: for each $i$ in $D$, we can find an expression for $x_i$ in terms of the variables without their index in $D$.  Here $D=\set{1,\,2,\,4}$, so
<alignmath> x_1+2x_3+5x_5=6
<![CDATA[\quad&\rightarrow\quad x_1=6-2x_3-5x_5\\]]> x_2-3x_3-2x_5=9
<![CDATA[\quad&\rightarrow\quad x_2=9+3x_3+2x_5\\]]>
<![CDATA[x_4+x_5=-8\quad&\rightarrow\quad x_4=-8-x_5]]>
</alignmath>
As a set, we write the solutions precisely as
<alignmath>
<![CDATA[S&=\setparts{\colvector{6-2x_3-5x_5\\9+3x_3+2x_5\\x_3\\-8-x_5\\x_5}}{x_3,\,x_5\in\complexes}]]>
</alignmath>
</solution>
</exercise>

<exercise type="C" number="19" rough=" 4x2 system, unique">
<problem contributor="robertbeezer">
<alignmath>
<![CDATA[ 2x_1 + x_2 &= 6 \\]]>
<![CDATA[ -x_1 - x_2 &= -2 \\]]>
<![CDATA[ 3x_1 + 4x_2 &= 4 \\]]>
<![CDATA[ 3x_1 + 5x_2 &= 2]]>
</alignmath>
</problem>
<solution contributor="robertbeezer">We form the augmented matrix of the system,
<alignmath>
<![CDATA[&\begin{bmatrix}]]>
<![CDATA[ 2 & 1 & 6 \\]]>
<![CDATA[ -1 & -1 & -2 \\]]>
<![CDATA[ 3 & 4 & 4 \\]]>
<![CDATA[ 3 & 5 & 2]]>
\end{bmatrix}
</alignmath>
which row-reduces to
<alignmath>
<![CDATA[&\begin{bmatrix}]]>
<![CDATA[ \leading{1} & 0 & 4 \\]]>
<![CDATA[ 0 & \leading{1} & -2 \\]]>
<![CDATA[ 0 & 0 & 0 \\]]>
<![CDATA[ 0 & 0 & 0]]>
\end{bmatrix}
</alignmath>
This augmented matrix represents the linear system $x_1=4$, $x_2=-2$, $0=0$, $0=0$, which clearly has only one possible solution.  We can write this solution set then as
<alignmath>
<![CDATA[S&=\set{\colvector{4\\-2}}]]>
</alignmath>
</solution>
</exercise>

</exercisegroup>

<exercisegroup>
<p>For problems C30<ndash />
C33, row-reduce the matrix without the aid of a calculator, indicating the row operations you are using at each step using the notation of <acroref type="definition" acro="RO" />
.</p>

<exercise type="C" number="30" rough="Row-reduce 3x4 by hand">
<problem contributor="robertbeezer">
<alignmath>
\begin{bmatrix}
<![CDATA[2 & 1 & 5 & 10\\]]>
<![CDATA[1 & -3 & -1 & -2\\]]>
<![CDATA[4 & -2 & 6 & 12]]>
\end{bmatrix}
</alignmath>
</problem>
<solution contributor="robertbeezer">
<alignmath>
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[2 & 1 & 5 & 10\\]]>
<![CDATA[1 & -3 & -1 & -2\\]]>
<![CDATA[4 & -2 & 6 & 12]]>
\end{bmatrix}
\xrightarrow{\rowopswap{1}{2}}
\begin{bmatrix}
<![CDATA[1 & -3 & -1 & -2\\]]>
<![CDATA[2 & 1 & 5 & 10\\]]>
<![CDATA[4 & -2 & 6 & 12]]>
\end{bmatrix}\\
\xrightarrow{\rowopadd{-2}{1}{2}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[1 & -3 & -1 & -2\\]]>
<![CDATA[0 & 7 & 7 & 14\\]]>
<![CDATA[4 & -2 & 6 & 12]]>
\end{bmatrix}
\xrightarrow{\rowopadd{-4}{1}{3}}
\begin{bmatrix}
<![CDATA[1 & -3 & -1 & -2\\]]>
<![CDATA[0 & 7 & 7 & 14\\]]>
<![CDATA[0 & 10 & 10 & 20]]>
\end{bmatrix}\\
\xrightarrow{\rowopmult{\frac{1}{7}}{2}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[1 & -3 & -1 & -2\\]]>
<![CDATA[0 & 1 & 1 & 2\\]]>
<![CDATA[0 & 10 & 10 & 20]]>
\end{bmatrix}
\xrightarrow{\rowopadd{3}{2}{1}}
\begin{bmatrix}
<![CDATA[1 & 0 & 2 & 4\\]]>
<![CDATA[0 & 1 & 1 & 2\\]]>
<![CDATA[0 & 10 & 10 & 20]]>
\end{bmatrix}\\
\xrightarrow{\rowopadd{-10}{2}{3}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[\leading{1} & 0 & 2 & 4\\]]>
<![CDATA[0 & \leading{1} & 1 & 2\\]]>
<![CDATA[0 & 0 & 0 & 0]]>
\end{bmatrix}
</alignmath>
</solution>
</exercise>

<exercise type="C" number="31" rough="Row-reduce 3x3 by hand">
<problem contributor="robertbeezer">
<alignmath>
\begin{bmatrix}
<![CDATA[ 1 & 2 & -4 \\]]>
<![CDATA[ -3 & -1 & -3 \\]]>
<![CDATA[ -2 & 1 & -7]]>
\end{bmatrix}
</alignmath>
</problem>
<solution contributor="robertbeezer">
<alignmath>
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[ 1 & 2 & -4 \\]]>
<![CDATA[ -3 & -1 & -3 \\]]>
<![CDATA[ -2 & 1 & -7]]>
\end{bmatrix}
\xrightarrow{\rowopadd{3}{1}{2}}
\begin{bmatrix}
<![CDATA[ 1 & 2 & -4 \\]]>
<![CDATA[ 0 & 5 & -15 \\]]>
<![CDATA[ -2 & 1 & -7]]>
\end{bmatrix}\\
\xrightarrow{\rowopadd{2}{1}{3}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[ 1 & 2 & -4 \\]]>
<![CDATA[ 0 & 5 & -15 \\]]>
<![CDATA[ 0 & 5 & -15]]>
\end{bmatrix}
\xrightarrow{\rowopmult{\frac{1}{5}}{2}}
\begin{bmatrix}
<![CDATA[ 1 & 2 & -4 \\]]>
<![CDATA[ 0 & 1 & -3 \\]]>
<![CDATA[ 0 & 5 & -15]]>
\end{bmatrix}\\
\xrightarrow{\rowopadd{-2}{2}{1}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[ 1 & 0 & 2 \\]]>
<![CDATA[ 0 & 1 & -3 \\]]>
<![CDATA[ 0 & 5 & -15]]>
\end{bmatrix}
\xrightarrow{\rowopadd{-5}{2}{3}}
\begin{bmatrix}
<![CDATA[ \leading{1} & 0 & 2 \\]]>
<![CDATA[ 0 & \leading{1} & -3 \\]]>
<![CDATA[ 0 & 0 & 0]]>
\end{bmatrix}
</alignmath>
</solution>
</exercise>

<exercise type="C" number="32" rough="Row-reduce 3x3 by hand">
<problem contributor="robertbeezer">
<alignmath>
\begin{bmatrix}
<![CDATA[1 & 1 & 1 \\]]>
<![CDATA[-4 & -3 & -2 \\]]>
<![CDATA[3 & 2 & 1]]>
\end{bmatrix}
</alignmath>
</problem>
<solution contributor="robertbeezer">Following the algorithm of <acroref type="theorem" acro="REMEF" />
, and working to create pivot columns from left to right, we have
<alignmath>
\begin{bmatrix}
<![CDATA[1 & 1 & 1 \\]]>
<![CDATA[-4 & -3 & -2 \\]]>
<![CDATA[3 & 2 & 1]]>
\end{bmatrix}
\xrightarrow{\rowopadd{4}{1}{2}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[1 & 1 & 1 \\]]>
<![CDATA[0 & 1 & 2 \\]]>
<![CDATA[3 & 2 & 1]]>
\end{bmatrix}
\xrightarrow{\rowopadd{-3}{1}{3}}
\begin{bmatrix}
<![CDATA[\leading{1} & 1 & 1 \\]]>
<![CDATA[0 & 1 & 2 \\]]>
<![CDATA[0 & -1 & -2]]>
\end{bmatrix}\\
\xrightarrow{\rowopadd{-1}{2}{1}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[\leading{1} & 0 & -1 \\]]>
<![CDATA[0 & 1 & 2 \\]]>
<![CDATA[0 & -1 & -2]]>
\end{bmatrix}
\xrightarrow{\rowopadd{1}{2}{3}}
\begin{bmatrix}
<![CDATA[\leading{1} & 0 & -1 \\]]>
<![CDATA[0 & \leading{1} & 2 \\]]>
<![CDATA[0 & 0 & 0]]>
\end{bmatrix}
</alignmath>
</solution>
</exercise>

<exercise type="C" number="33" rough="Row-reduce 3x4 by hand">
<problem contributor="robertbeezer">
<alignmath>
\begin{bmatrix}
<![CDATA[1 & 2 & -1 & -1 \\]]>
<![CDATA[2 & 4 & -1 & 4 \\]]>
<![CDATA[-1 & -2 & 3 & 5]]>
\end{bmatrix}
</alignmath>
</problem>
<solution contributor="robertbeezer">Following the algorithm of <acroref type="theorem" acro="REMEF" />
, and working to create pivot columns from left to right, we have
<alignmath>
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[1 & 2 & -1 & -1 \\]]>
<![CDATA[2 & 4 & -1 & 4 \\]]>
<![CDATA[-1 & -2 & 3 & 5]]>
\end{bmatrix}
\xrightarrow{\rowopadd{-2}{1}{2}}
\begin{bmatrix}
<![CDATA[1 & 2 & -1 & -1 \\]]>
<![CDATA[0 & 0 & 1 & 6 \\]]>
<![CDATA[-1 & -2 & 3 & 5]]>
\end{bmatrix}\\
\xrightarrow{\rowopadd{1}{1}{3}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[\leading{1} & 2 & -1 & -1 \\]]>
<![CDATA[0 & 0 & 1 & 6 \\]]>
<![CDATA[0 & 0 & 2 & 4]]>
\end{bmatrix}
\xrightarrow{\rowopadd{1}{2}{1}}
\begin{bmatrix}
<![CDATA[\leading{1} & 2 & 0 & 5 \\]]>
<![CDATA[0 & 0 & 1 & 6 \\]]>
<![CDATA[0 & 0 & 2 & 4]]>
\end{bmatrix}\\
\xrightarrow{\rowopadd{-2}{2}{3}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[\leading{1} & 2 & 0 & 5 \\]]>
<![CDATA[0 & 0 & \leading{1} & 6 \\]]>
<![CDATA[0 & 0 & 0 & -8]]>
\end{bmatrix}
\xrightarrow{\rowopmult{-\frac{1}{8}}{3}}
\begin{bmatrix}
<![CDATA[\leading{1} & 2 & 0 & 5 \\]]>
<![CDATA[0 & 0 & \leading{1} & 6 \\]]>
<![CDATA[0 & 0 & 0 & 1]]>
\end{bmatrix}\\
\xrightarrow{\rowopadd{-6}{3}{2}}
<![CDATA[&]]>
\begin{bmatrix}
<![CDATA[\leading{1} & 2 & 0 & 5 \\]]>
<![CDATA[0 & 0 & \leading{1} & 0 \\]]>
<![CDATA[0 & 0 & 0 & 1]]>
\end{bmatrix}
\xrightarrow{\rowopadd{-5}{3}{1}}
\begin{bmatrix}
<![CDATA[\leading{1} & 2 & 0 & 0 \\]]>
<![CDATA[0 & 0 & \leading{1} & 0 \\]]>
<![CDATA[0 & 0 & 0 & \leading{1}]]>
\end{bmatrix}
</alignmath>
</solution>
</exercise>

</exercisegroup>

<exercise type="M" number="40" rough="Row space computations on row-equivalent 3x4 matrices">
<problem contributor="robertbeezer">Consider the two $3\times 4$ matrices below
<alignmath>
<![CDATA[B&=]]>
\begin{bmatrix}
<![CDATA[1 & 3 & -2 & 2 \\]]>
<![CDATA[-1 & -2 & -1 & -1 \\]]>
<![CDATA[-1 & -5 & 8 & -3]]>
\end{bmatrix}
<![CDATA[&]]>
<![CDATA[C&=]]>
\begin{bmatrix}
<![CDATA[1 & 2 & 1 & 2 \\]]>
<![CDATA[1 & 1 & 4 & 0 \\]]>
<![CDATA[-1 & -1 & -4 & 1]]>
\end{bmatrix}
</alignmath>
<br />
<br />
<ol>
<li>Row-reduce each matrix and determine that the reduced row-echelon forms of $B$ and $C$ are identical.  From this argue that $B$ and $C$ are row-equivalent.</li>
<li>In the proof of <acroref type="theorem" acro="RREFU" />
, we begin by arguing that entries of row-equivalent matrices are related by way of certain scalars and sums.  In this example, we would write that entries of $B$ from row $i$ that are in column $j$ are linearly related to the entries of $C$ in column $j$ from all three rows
<alignmath>
\matrixentry{B}{ij}
<![CDATA[&=]]>
\delta_{i1}\matrixentry{C}{1j}+
\delta_{i2}\matrixentry{C}{2j}+
\delta_{i3}\matrixentry{C}{3j}
<![CDATA[&]]>
<![CDATA[1&\leq j\leq 4]]>
</alignmath>
For each $1\leq i\leq 3$ find the corresponding three scalars in this relationship.  So your answer will be nine scalars, determined three at a time.</li>
</ol>
</problem>
<solution contributor="robertbeezer">
<ol>
<li>Let $R$ be the common reduced row-echelon form of $B$ and $C$.  A sequence of row operations converts $B$ to $R$ and a second sequence of row operations converts $C$ to $R$. If we <q>reverse</q> the second sequence's order, and reverse each individual row operation (see <acroref type="exercise" acro="RREF.T10" />
) then we can begin with $B$, convert to $R$ with the first sequence, and then convert to $C$ with the reversed sequence.  Satisfying <acroref type="definition" acro="REM" />
 we can say $B$ and $C$ are row-equivalent matrices.</li>
<li>We will work this carefully for the first row of $B$ and just give the solution for the next two rows.  For row 1 of $B$ take $i=1$ and we have
<alignmath>
\matrixentry{B}{1j}
<![CDATA[&=]]>
\delta_{11}\matrixentry{C}{1j}+
\delta_{12}\matrixentry{C}{2j}+
\delta_{13}\matrixentry{C}{3j}
<![CDATA[&]]>
<![CDATA[1&\leq j\leq 4]]>
</alignmath>
If we substitute the four values for $j$ we arrive at four linear equations in the three unknowns $\delta_{11}, \delta_{12}, \delta_{13}$,
<alignmath>
<![CDATA[(j=1)&]]>
<![CDATA[&]]>
\matrixentry{B}{11}
<![CDATA[&=]]>
\delta_{11}\matrixentry{C}{11}+
\delta_{12}\matrixentry{C}{21}+
\delta_{13}\matrixentry{C}{31}
<![CDATA[&]]>
<![CDATA[&\Rightarrow]]>
<![CDATA[&]]>
1
<![CDATA[&=]]>
\delta_{11}(1)+
\delta_{12}(1)+
\delta_{13}(-1)\\
<![CDATA[(j=2)&]]>
<![CDATA[&]]>
\matrixentry{B}{12}
<![CDATA[&=]]>
\delta_{11}\matrixentry{C}{12}+
\delta_{12}\matrixentry{C}{22}+
\delta_{13}\matrixentry{C}{32}
<![CDATA[&]]>
<![CDATA[&\Rightarrow]]>
<![CDATA[&]]>
3
<![CDATA[&=]]>
\delta_{11}(2)+
\delta_{12}(1)+
\delta_{13}(-1)\\
<![CDATA[(j=3)&]]>
<![CDATA[&]]>
\matrixentry{B}{13}
<![CDATA[&=]]>
\delta_{11}\matrixentry{C}{13}+
\delta_{12}\matrixentry{C}{23}+
\delta_{13}\matrixentry{C}{33}
<![CDATA[&]]>
<![CDATA[&\Rightarrow]]>
<![CDATA[&]]>
-2
<![CDATA[&=]]>
\delta_{11}(1)+
\delta_{12}(4)+
\delta_{13}(-4)\\
<![CDATA[(j=4)&]]>
<![CDATA[&]]>
\matrixentry{B}{14}
<![CDATA[&=]]>
\delta_{11}\matrixentry{C}{14}+
\delta_{12}\matrixentry{C}{24}+
\delta_{13}\matrixentry{C}{34}
<![CDATA[&]]>
<![CDATA[&\Rightarrow]]>
<![CDATA[&]]>
2
<![CDATA[&=]]>
\delta_{11}(2)+
\delta_{12}(0)+
\delta_{13}(1)
</alignmath>
We form the augmented matrix of this system and row-reduce to find the solutions,
<alignmath>
\begin{bmatrix}
<![CDATA[1 & 1 & -1 & 1 \\]]>
<![CDATA[2 & 1 & -1 & 3 \\]]>
<![CDATA[1 & 4 & -4 & -2 \\]]>
<![CDATA[2 & 0 & 1 & 2]]>
\end{bmatrix}
<![CDATA[&\rref]]>
\begin{bmatrix}
<![CDATA[\leading{1} & 0 & 0 & 2 \\]]>
<![CDATA[0 & \leading{1} & 0 & -3 \\]]>
<![CDATA[0 & 0 & \leading{1} & -2 \\]]>
<![CDATA[0 & 0 & 0 & 0]]>
\end{bmatrix}
</alignmath>
So the unique solution is $\delta_{11}=2$, $\delta_{12}=-3$, $\delta_{13}=-2$.  Entirely similar work will lead you to
<alignmath>
<![CDATA[\delta_{21}&=-1]]>
<![CDATA[&]]>
<![CDATA[\delta_{22}&=1]]>
<![CDATA[&]]>
<![CDATA[\delta_{23}&=1]]>
<intertext>and</intertext>
<![CDATA[\delta_{31}&=-4]]>
<![CDATA[&]]>
<![CDATA[\delta_{32}&=8]]>
<![CDATA[&]]>
<![CDATA[\delta_{33}&=5]]>
</alignmath>
</li>
</ol>
</solution>
</exercise>

<exercise type="M" number="45" rough="Lizards, mice, peacocks (oh my!)">
<problem contributor="chrisblack">You keep a number of lizards, mice and peacocks as pets.  There are a total of 108 legs and 30 tails in your menagerie.  You have twice as many mice as lizards.  How many of each creature do you have?
</problem>
<solution contributor="chrisblack">Let $l, m, p$ denote the number of lizards, mice and peacocks.  Then the statements from the problem yield the equations:
<alignmath>
<![CDATA[4l+4m+2p&=108\\]]>
<![CDATA[l+m+p &= 30\\]]>
<![CDATA[2l-m&=0]]>
</alignmath>
We form the augmented matrix for this system and row-reduce
<alignmath>
\begin{bmatrix}
<![CDATA[4 & 4 & 2 & 108\\]]>
<![CDATA[1 & 1 & 1 & 30\\]]>
<![CDATA[2 & -1 & 0 & 0]]>
\end{bmatrix}
<![CDATA[&\rref]]>
\begin{bmatrix}
<![CDATA[\leading{1} & 0 & 0 &  8\\]]>
<![CDATA[0 & \leading{1} & 0 &  16\\]]>
<![CDATA[0 & 0 & \leading{1} &  6]]>
\end{bmatrix}
</alignmath>
From the row-reduced matrix, we see that we have an equivalent system $l=8$, $m=16$, and $p=6$, which means that you have 8 lizards, 16 mice and 6 peacocks.
</solution>
</exercise>

<exercise type="M" number="50" rough="Cars, trucks, etc in parking lot">
<problem contributor="robertbeezer">A parking lot has 66 vehicles (cars, trucks, motorcycles and bicycles)  in it.  There are four times as many cars as trucks.  The total number of tires (4 per car or truck, 2 per motorcycle or bicycle) is 252.  How many cars are there?  How many bicycles?
</problem>
<solution contributor="robertbeezer">Let $c,\,t,\,m,\,b$ denote the number of cars, trucks, motorcycles, and bicycles.  Then the statements from the problem yield the equations:
<alignmath>
<![CDATA[c+t+m+b&=66\\]]>
<![CDATA[c-4t&=0\\]]>
<![CDATA[4c+4t+2m+2b&=252]]>
</alignmath>
We form the augmented matrix for this system and row-reduce
<alignmath>
\begin{bmatrix}
<![CDATA[1 & 1 & 1 & 1 & 66\\]]>
<![CDATA[1 & -4 & 0 & 0 & 0\\]]>
<![CDATA[4 & 4 & 2 & 2 & 252]]>
\end{bmatrix}
<![CDATA[&\rref]]>
\begin{bmatrix}
<![CDATA[\leading{1} & 0 & 0 & 0 & 48\\]]>
<![CDATA[0 & \leading{1} & 0 & 0 & 12\\]]>
<![CDATA[0 & 0 & \leading{1} & 1 & 6]]>
\end{bmatrix}
</alignmath>
The first  row of the matrix represents the equation $c=48$, so there are 48 cars.
The second row of the matrix represents the equation $t=12$, so there are 12 trucks.
The third  row of the matrix represents the equation $m+b=6$ so there are anywhere from 0 to 6 bicycles.
We can also say that $b$ is a free variable, but the context of the problem limits it to 7 integer values since you cannot have a negative number of motorcycles.
</solution>
</exercise>

<exercise type="T" number="10" rough="Row operations are reversible">
<problem contributor="robertbeezer">Prove that each of the three row operations (<acroref type="definition" acro="RO" />
) is reversible.  More precisely, if the matrix $B$ is obtained from $A$ by application of a single row operation, show that there is a single row operation that will transform $B$ back into $A$.
</problem>
<solution contributor="robertbeezer">If we can reverse each row operation individually, then we can reverse a sequence of row operations.  The operations that reverse each operation are listed below, using our shorthand notation.  Notice how requiring the scalar $\alpha$ to be nonzero makes the second operation reversible.
<alignmath>
<![CDATA[\rowopswap{i}{j}&\quad\quad\rowopswap{i}{j}\\]]>
<![CDATA[\rowopmult{\alpha}{i},\,\alpha\neq 0&\quad\quad\rowopmult{\frac{1}{\alpha}}{i}\\]]>
<![CDATA[\rowopadd{\alpha}{i}{j}&\quad\quad\rowopadd{-\alpha}{i}{j}]]>
</alignmath>
</solution>
</exercise>

<exercise type="T" number="11" rough="Row-equivalence is an equivalence relation">
<problem contributor="robertbeezer">Suppose that $A$, $B$ and $C$ are $m\times n$ matrices.  Use the definition of row-equivalence (<acroref type="definition" acro="REM" />
) to prove the following three facts.
<ol>
<li> $A$ is row-equivalent to $A$.
</li>
<li> If $A$ is row-equivalent to $B$, then $B$ is row-equivalent to $A$.
</li>
<li> If $A$ is row-equivalent to $B$, and $B$ is row-equivalent to $C$, then $A$ is row-equivalent to $C$.
</li>
</ol>
A relationship that satisfies these three properties is known as an <define>equivalence relation</define>, an important idea in the study of various algebras.  This is a formal way of saying that a relationship behaves like equality, without requiring the relationship to be as strict as equality itself.   We will see it again in <acroref type="theorem" acro="SER" />
.
</problem>
</exercise>

<exercise type="T" number="12" rough="Contiguous rows, front columns still in rref">
<problem contributor="robertbeezer">Suppose that $B$ is an $m\times n$ matrix in reduced row-echelon form.  Build a new, likely smaller, $k\times\ell$ matrix $C$ as follows.  Keep any collection of $k$ adjacent rows, $k\leq m$.  From these rows, keep columns $1$ through $\ell$, $\ell\leq n$.  Prove that $C$ is in reduced row-echelon form.
</problem>
</exercise>

<exercise type="T" number="13" rough="Relax T12, rows not contiguous">
<problem contributor="robertbeezer">Generalize <acroref type="exercise" acro="RREF.T12" />
 by just keeping any $k$ rows, and not requiring the rows to be adjacent.  Prove that any such matrix $C$ is in reduced row-echelon form.
</problem>
</exercise>

</exercisesubsection>

</section>
